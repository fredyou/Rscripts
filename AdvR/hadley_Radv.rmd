
OO field Guide
```{r OO field guide}
library(pryr)
#############
##base types#
#############
is.object(sum) #False

############
##s3 class##
############

#In S3, methods belong to functions, called generic functions, or generics for short. S3 methods do not belong to objects or classes. 
functiontype=function (f) 
{
    fexpr <- substitute(f)
    env <- parent.frame()
    fname <- if (is.name(fexpr)) 
        as.character(fexpr)
    else NULL
    if (is.primitive(f)) {
        c("primitive", if (is_internal_generic(primitive_name(f))) "generic")
    }
    else if (is_internal(f)) {
        c("internal", if (is_internal_generic(internal_name(f))) "generic")
    }
    else if (is(f, "standardGeneric")) {
        c("s4", "generic")
    }
    else if (is(f, "MethodDefinition")) {
        c("s4", "method")
    }
    else if (is(f, "refMethodDef")) {
        c("rc", "method")
    }
    else if (!is.null(fname) && is_s3_generic(fname, env)) {
        c("s3", "generic")
    }
    else if (!is.null(fname) && is_s3_method(fname, env)) {
        c("s3", "method")
    }
    else {
        c("function")
    }
}

##check S3 methods##
#check methods belong to a generic method in base package
methods(mean)
#list all generic methods of a given class:
methods(class="ts") #ts is an object in stats pacakge
#get source code of s3 method defined in packages other than base package
getS3method()
#Note!! is.Generic() is used only for S4 method

##create S3 class##
foo=structure(list(),class="foo")
class(foo)
inherits(foo,"foo")

#constructor function
foo <- function(x) {
  if (!is.numeric(x)) stop("X must be numeric")
  structure(list(x), class = "foo")
}

#generic function assign
f.a=function(x) "Class a"
a=structure(list(),class="a")

#Method dispatch
f <- function(x) UseMethod("f") 
#without this,method wouldnt be dispatched 
# UseMethod currently dispatches on the implicit class even for arguments that are not objects(base type), but the other means of dispatch do not.
f.a <- function(x) "Class a"
f.default <- function(x) "Unknown class"

##Group generics
?"groupGeneric"
#group generics dispatch on the oldClass not class for efficiency
#oldclass return and set class but are implemented in a diff way
#If the object does not have a class attribute, it has an implicit class, "matrix", "array" or the result of mode(x). (Functions oldClass and oldClass<- get and set the attribute, which can also be done directly.

##NextMethod
?NextMethod


#force R to call the wrong method
f.default(a) #this is only used to skip method dispatch
iclass <- function(x) {
  if (is.object(x)) {
    stop("x is not a primitive type", call. = FALSE)
  }

  c(
    if (is.matrix(x)) "matrix",
    if (is.array(x) && !is.matrix(x)) "array",
    if (is.double(x)) "double",
    if (is.integer(x)) "integer",
    mode(x)
  )
}
iclass(matrix(1:5))
#Here matrix is a non-S3 obj

####Excercise:
#4.Which base generic has the greatest number of defined methods?
baseobj=ls(envir = as.environment("package:base"))
baseobj=Filter(function(f){is.function(get(f))},baseobj)
checkgeneric=function(f){
  type=""
  #print(f)
  if(f=="F") return(NULL);
  if (pryr:::is_s3_generic(f)) {
       type= c("generic")
    }
    else if (pryr:::is_s3_method(f)) {
       type= c("method")
    }
  grepl("generic",type)
}
genericFuncs=Filter(checkgeneric,baseobj)
methodcount=sapply(genericFuncs,function(x){length(methods(x))})
which(methodcount==max(methodcount))

#6Internal generics don’t dispatch on the implicit class of base types. 
#so functions with no $class attribute will not be dispatched internal methods

############
##s4 class##
############
# Methods still belong to functions, not classes, but:
# 
# Classes have formal definitions which describe their fields and inheritance structures (parent classes).
# 
# Method dispatch can be based on multiple arguments to a generic function, not just one.
# 
# There is a special operator, @, for extracting slots (aka fields) from an S4 object.

# All S4 related code is stored in the methods package. This package is always available when you’re running R interactively, but may not be available when running R in batch mode. For this reason, it’s a good idea to include an explicit library(methods) whenever you’re using S4.


y <- c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8)
nLL <- function(lambda) - sum(dpois(y, lambda, log = TRUE))
fit <- mle(nLL, start = list(lambda = 5), nobs = length(y))
# Retrieve an S4 method, described later
ftype(nobs)
mle_nobs <- method_from_call(nobs(fit))
isS4(mle_nobs)
#> [1] TRUE
ftype(mle_nobs)
#> [1] "s4"     "method"

#nobs is the generic S4 func, nobs(fit) call method that belong to nobs.

##Check inheritance###
is(fit) #show parent classes
is(fit,"mle") #test inheritances

##check source code
showmethods(nobs) #object="ANY" means input not specified
getMethod(nobs,signature="ANY")
getMethod(nobs,signature="mle")

##list all S4 generics and S4 classes
getGenerics();getClasses();
##list all S4 methods
#showMethods(),by generics or by class, where=search() :globalEnv

###Define classes and create objs####
#define representation of class:
setClass()
#create obj
new()
# find the documentation for a class 
class?mle
#class name convention:
UpperCamelCase

###Three elements in S4:name, slots, contains: super
setClass("Person",
  slots = list(name = "character", age = "numeric"))
setClass("Employee",
  slots = list(boss = "Person"),
  contains = "Person")

alice <- new("Person", name = "Alice", age = 40)
john <- new("Employee", name = "John", age = 20, boss = alice)
#new() could be replaced with a constructor func

###If an S4 object contains (inherits from) an S3 class or a base type, it will have a special .Data slot which contains the underlying base type or S3 object:
setClass("RangedNumeric",
  contains = "numeric",
  slots = list(min = "numeric", max = "numeric"))
rn <- new("RangedNumeric",  min = 1, max = 10,1:10)
rn@min
rn@.Data

###Create or set function to be generic
#if there is function already
setGeneric("union")
setMethod("union",c(x="data.frame",y="data.frame"),function(x,y){unique(rbind(x,y))}) 
#generic name, classes the method shall be associated with, a func implements the method

#if create generic from scratch:
setGeneric("myGeneric", function(x) {
  standardGeneric("myGeneric")
})

###Method dispatch
selectMethod("nobs",list("mle"))  
#similar to getMethod(genericname,signature)
method_from_call(nobs(fit))


###Initialize Method
track <- setClass("track",
         slots = c(x="numeric", y="numeric"))
trackCurve <- setClass("trackCurve",
    slots = c(smooth = "numeric"),
    contains = "track")

setMethod("initialize",
          "track",
          function(.Object, x = numeric(0), y = numeric(0)) {
            if(nargs() > 1) {
              if(length(x) != length(y))
                stop("specified x and y of different lengths")
              .Object@x <- x
              .Object@y <- y
            }
            .Object
          })
#above initialize func will apply to both track and trackCurve so:
t1 <- track(x = 1:10, y = 1:10 + rnorm(10))
t2 <- new("trackCurve", t1, smooth = 22) #WOULD NOT WORK!!

#Better init in this way
setMethod("initialize", "track", function(.Object, ...) {
    .Object <- callNextMethod()
    if(length(.Object@x) != length(.Object@y))
     stop("specified x and y of different lengths")
    .Object
  })
t1 <- track(x = 1:10, y = 1:10 + rnorm(10))
t2 <- new("trackCurve", t1, smooth = 22) #WORKED


###callNextMethod###
#call parents` methods until to generic function
setClass("B0" , representation(b0 = "numeric"))

setClass("B1", representation(b1 = "character"), contains = "B0")

setClass("B2", representation(b2 = "logical"), contains = "B1")

## and a rather silly function to illustrate callNextMethod
f <- function(x) class(x)
setMethod("f", "B0", function(x) c(x@b0^2, callNextMethod()))
setMethod("f", "B1", function(x) c(paste(x@b1,":"), callNextMethod()))
setMethod("f", "B2", function(x) c(x@b2, callNextMethod()))
b1 <- new("B1", b0 = 2, b1 = "Testing")
b2 <- new("B2", b2 = FALSE, b1 = "More testing", b0 = 10)
f(b1)
#Here f function has methods for "ANY","B0"...,
#callNextMethod would call f.B1->f.B0->f.ANY

###replacement function# change the value without copy
setClass("foo", representation(a = "ANY"))
setGeneric("a",  function(object) standardGeneric("a"))
setMethod("a", "foo", function(object) object@a)
b <- new("foo", a = 10)
a(b)
#a(b)=12: Error couldnt find function a<-

#lets build generic replace func
setGeneric("a<-", function(x, value) standardGeneric("a<-"))
setReplaceMethod("a", "foo", function(x, value) {
  x@a<-value
  x
})
a(b)=32
#however, this b has different address now

###Exercise1 Which S4 generic has the most methods defined for it? Which S4 class has the most methods associated with it?
s4genericglobal=Filter(function(f){if(exists(f)){isS4(get(f))}else F},getGenerics()@.Data) #filter out s4 generics
count=sapply(
  s4genericglobal,
  function(x){ length(findMethods(x)@signatures)})
which(count==max(count)) #coerce 8

s4classesglobal=Filter(function(f){isS4(getClass(f,where=search()))},getClasses(where=search()))
count=sapply(
  s4classesglobal,
  function(x){ length(showMethods(class=x,printTo=F)[ grep("Function",showMethods(class="RangedNumeric", printTo =FALSE ))])})
which(count==max(count)) 

###Exercise2 What happens if you define a new S4 class that doesn’t “contain” an existing class? (Hint: read about virtual classes in ?Classes.)
setClass("Person") OR #setClass("Person",slots...,contains="VIRTUAL")
#cannot use new() to create objects but could be extended by subclass

###Exercise3 What happens if you pass an S4 object to an S3 generic? What happens if you pass an S3 object to an S4 generic? (Hint: read ?setOldClass for the second case.)
#s3 class
stamped <- function(x, date = Sys.time()) {
    if(!inherits(date, "POSIXt"))
      stop("bad date argument")
    if(!is.vector(x))
      stop("x must be a vector")
    attr(x, "date") <- date
    class(x) <- "stamped"
    x
}

print.stamped <- function(x, ...) {
    print(as.vector(x))
    cat("Date: ",  format(attr(x,"date")), "s3print\n")
}
test=function(x,...){
  UseMethod("test")
}
# test.vector=function(x){
#   print("This is test.vector function for stamped s3 class")
# }
test.stamped=function(x){
  print("This is the test.stamped function for stamped s3 class")
}
x=stamped("xxx")

##Pass s4 to s3 generic (), but s4 must be a class converted from s3 by setOldClass(s3,S4Class=s4)

setClass("stamped4", contains = "vector", representation(date = "POSIXt"))
#This is the important part, stamped4 extends vector, then setOldClass make stamped extends stamped4
#so when test function is called on s3 obj of stamped, it searches for 
# setGeneric("test",function(object) {
#   standardGeneric("test")
# })

#setOldClass("stamped", S4Class = "stamped4") #convert stamped to stamped4 that extends vector
#And add oldclass to extends as well.
#selectMethod("show", "stamped") #
#selectMethod("test","stamped") #This will report an error, because s4 generic test havent been defined
#But, you cannot setGeneric("test",...) cuz it will override s3 test function
#What u could do is: setMethod("test","stamped4",function....) and then selectMethod, this will link #s4method to s3 method 
#or just don`t add this command, and u would directly invoke s3 test
removeClass("stamped4")
someLetters <- stamped(sample(letters, 10),
                       ISOdatetime(2008, 10, 15, 12, 0, 0))
st <- new("stamped", someLetters)
test(x) #s3 generic call s4 class

##S4 generic call s3 obj
x=stamped("xxx")
setGeneric("test",function(object) {
  standardGeneric("test")
})
setMethod("test","stamped4",function(object){print("This is test function for stamped4 s4 class")})
#test(x) #Because test generic has been overriden, it returns an error
setOldClass(c("stamped","stamped4"),S4Class="stamped4") 
#connect stamped with S3Class(stamped4) and then stamped, S3Class(stamped4) extends stamped4
#

selectMethod("test", "stamped")
test(x) #now stamped is also a s4 class
#setOldClass("stamped", S4Class = "stamped4") #this along dont extend stamped4 but oldclas
###Good Example of S4 OOP: Model bank and cashpoints: Basetra/programming/prediction.R


###################
##Reference class##
###################
###Exercise1
Account <- setRefClass("Account",
  fields = list(.balance = "numeric"),
  methods = list(
    withdraw = function(x) {
      temp=.balance-x
      print(temp)
      return(Account$new(.balance=temp)) 
    },
    deposit = function(x) {
      .balance <<- .balance + x
    },
    getBalance=function(){
      return(.balance)
    }
    
  )
)
Account$lock(".balance")
a=Account$new(.balance=100)

NoOverdraft <- setRefClass("NoOverdraft",
  contains = "Account",
  methods = list(
    withdraw = function(x) {
      if (.balance < x) stop("Not enough money")
      .balance <<- .balance - x
    }
  )
)
accountJohn <- NoOverdraft$new(.balance = 100)


```

Chapter 8 Environments
```{r chapter 8 environments}
#Exercise2 Write your own version of get() using a function written in the style of where().
get=function(name,env=parent.frame()){
  stopifnot(class(name)=="character")
  while(!identical(env,emptyenv())){
    #print(env)
    if(exists(name,env,inherits = FALSE)){return(env[[name]])}
    env=parent.env(env)
  }
}
e=new.env(parent=parent.frame())
e$name="This is for test get func"
attach(e) #IMPORTANT STEP, otherwise, look up procedure will not find "e"
##Or new.env(parent = emptyenv())
get("name")
parent.env(.GlobalEnv) #e


###four environments: enclosing env, binding env, execution env, calling env
#Exercise5 Write an enhanced version of str() that provides more information about functions. Show where the function was found and what environment it was defined in.
f1 <- function(x1) {
  f2 <- function(x2) {
    f3 <- function(x3) {
      x1 + x2 + x3
    }
    f3(3)
  }
  f2(2)
  
}
plus <- function(x) {
  function(y) x + y
}
plus_one <- plus(1)
identical(parent.env(environment(plus_one)), environment(plus))


pryrfunccall=function (f) 
{
    if (is.function(f)) {
        fun_calls(body(f))
    }
    else if (is.call(f)) {
        fname <- as.character(f[[1]])
        if (identical(fname, ".Internal")) 
            return(fname)
        unique(c(fname, unlist(lapply(f[-1], fun_calls), use.names = FALSE)))
    }
}

#####IMPORTANT!!!!! HOW TO CONVERT ENVIRONMENT TO STRING:
e=new.env()
#cat(e)#error
format(e) #character
####MANY OBJECT IS ACTUALLY FORMATED BEFORE INVOKING PRINT FUNCTION

?sys.frame
attach(e)
e$f2=f1
str.function=function(f){
  require(pryr)
  cat("Found in(enclosing env): ",format(environment(f)),"\n");
  cat("Defined in: ", format(where(as.character(substitute(f))))," Named: ",attr(where(as.character(substitute(f))),"name"))
  #str(f)
}

######################
##Bindings to values##
######################
###Delayed bindings
library(pryr)
system.time(b %<d-% {Sys.sleep(1); 1})
system.time(b)

##Active bindings
x %<a-% runif(1)
x
x #different

###Rebind
rebind <- function(name, value, env = parent.frame()) {
  if (identical(env, emptyenv())) {
    stop("Can't find ", name, call. = FALSE)
  } else if (exists(name, envir = env, inherits = FALSE)) {
    assign(name, value, envir = env)
  } else {
    rebind(name, value, parent.env(env))
  }
}

#compared with <<-, it rebinds name with variables of current calling environments,not parent.env

myassign<-function(name,value){
  require(pryr)
  flag=format(tryCatch({where(name)},error=function(e){return("Error")}))
  stopifnot(flag=="Error")
  assign(name,value)
}#if old name, assign break


##?? Exercise3: Write an assignment function that can do active, delayed, and locked bindings. What might you call it? What arguments should it take? Can you guess which sort of assignment it should do based on the input? 


###############################
##reference semantics of env###
###############################
modify <- function(x) {
  x$a <- 2
  invisible()
}
x <- 1
e1 <- new.env()
get("x", envir = e1)

e2 <- new.env(parent = emptyenv())
get("x", envir = e2) #error

# Environments are data structures useful for solving three common problems:
# 
# Avoiding copies of large data. #But Changes to R 3.1.0 have made this use substantially less important because modifying a list no longer makes a deep copy.
# Managing state within a package.
# Efficiently looking up values from names.
```

Debugging, condition handling, and defensive programming
```{r Debug}
##bug code
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) "a" + d
f(10)


browseOnce <- function() {
  old <- getOption("error")
  function() {
    options(error = old) #set options(error to null)
    browser() #but still execute browser() once
  }
}
options(error = browseOnce())

f <- function() stop("!")
# Enters browser
f()
# Runs normally
f()


###Convert warnings to errors
 options(warn = 2)
 
success <- try(1 + 2)
failure <- try("a" + "b")
class(success)
#> [1] "numeric"
class(failure)
#> [1] "try-error"

###tryCatch implement try
try2 <- function(code, silent = FALSE) {
  tryCatch(code, error = function(c) {
    msg <- conditionMessage(c)
    if (!silent) message(c)
    invisible(structure(msg, class = "try-error")) #IMPORTANT~~ create a string with class
  })
}

##interrupt
i <- 1
while(i < 3) {
  tryCatch({
    Sys.sleep(0.5)
    message("Try to escape")
  }, interrupt = function(x) {
    message("Try again!")
    i <<- i + 1
  })
}

###sys.calls() :runtime traceback()
f <- function() g()
g <- function() h()
h <- function() stop("!")
tryCatch(f(), error = function(e) print(sys.calls()))


####Distinguish different types of error####
# Conditions must contain message and call components, and may contain other useful components. When creating a new condition, it should always inherit from condition and one of error, warning, or message.

condition <- function(subclass, message, call = sys.call(-1), ...) {
  structure(
    class = c(subclass, "condition"),
    list(message = message, call = call),
    ...
  )
}
is.condition <- function(x) inherits(x, "condition")
c <- condition(c("my_error", "error"), "This is an error")


custom_stop <- function(subclass, message, call = sys.call(-1), 
                        ...) {
  c <- condition(c(subclass, "error"), message, call = call, ...)
  stop(c)
}

my_log <- function(x) {
  if (!is.numeric(x))
    custom_stop("invalid_class", "my_log() needs numeric input")
  if (any(x < 0))
    custom_stop("invalid_value", "my_log() needs positive inputs")

  log(x)
}

##Or
my_log <- function(x) {
  if (!is.numeric(x))
    c <- condition(c("invalid_class","error"), "my_log() needs numeric input")
    signalCondition(c) #This is important step to let tryCatch really catch the signal
  if (any(x < 0))
    c <- condition(c("invalid_value","error"), "my_log() needs positive input")
    signalCondition(c) #This is important step to let tryCatch really catch the signal

  log(x)
}

tryCatch(
  my_log("a"),
  invalid_class = function(c) "class",
  invalid_value = function(c) "value"
)
#this will first trigger the if stat in my_log, invoke custom_stop invalid_class and generate c condition

###Exercise: Difference between withCallingHandlers and tryCatch
message2error <- function(code) {
  withCallingHandlers(code, message = function(e) stop(e))
}
message2error("a"+1)
traceback() #Trace stoped at withCallingHandlers (it don`t return anything)
message2error <- function(code) {
  tryCatch(code, message = function(e) stop(e))
}
message2error("a"+1)
traceback() #traced back to steps in tryCatch

################################
###Defensive programming########
################################
## "Fail fast"
## Non-standard evaluation like subset, transform, and with often fail with uninformative error messages
## if your function is not vectorised in its inputs, but uses functions that are, make sure to check that the inputs are scalars. 
## Avoid functions that return different types of output depending on their input. 
##  never use sapply() inside a function: always use the stricter vapply() which will throw an error if the inputs are incorrect types and return the correct type of output even for zero-length inputs.
# vapply returns a vector or array of type matching the FUN.VALUE.


###Exercise : 
col_means <- function(df) {
  numeric <- sapply(df, is.numeric)
  numeric_cols <- df[, numeric]

  data.frame(lapply(numeric_cols, mean))
}

```

Functional Programming
```{r functional programming}
######################
##list of functnion###
######################
compute_mean <- list(
  base = function(x) mean(x),
  sum = function(x) sum(x) / length(x),
  manual = function(x) {
    total <- 0
    n <- length(x)
    for (i in seq_along(x)) {
      total <- total + x[i] / n
    }
    total
  }
)
lapply(compute_mean, function(f) f(x))
#> $base
#> [1] 0.4994771
#> 
#> $sum
#> [1] 0.4994771
#> 
#> $manual
#> [1] 0.4994771

call_fun <- function(f, ...) f(...)

lapply(compute_mean, call_fun, x)
#> $base
#> [1] 0.4994771
#> 
#> $sum
#> [1] 0.4994771
#> 
#> $manual
#> [1] 0.4994771
lapply(compute_mean, function(f) system.time(f(x)))

lapply(compute_mean, function(f) f(x, na.rm = TRUE))

######################################################
##Moving lists of functions to the global environment#
######################################################
simple_tag <- function(tag) {
  force(tag)
  function(...) {
    paste0("<", tag, ">", paste0(...), "</", tag, ">")
  }
}
tags <- c("p", "b", "i")
html <- lapply(setNames(tags, tags), simple_tag)
# keeping them in a list makes code more verbose:
html$p("This is ", html$b("bold"), " text.")

####three options to eliminate the use of html$:
#1.(recommended) for very temporary effect use with():
with(html, p("This is ", b("bold"), " text."))

#2. for longer effect use attach(), detach():
attach(html)
p("This is ", b("bold"), " text.")
#> [1] "<p>This is <b>bold</b> text.</p>"
detach(html)

#3. list2env
list2env(html, environment())
#> <environment: R_GlobalEnv>
p("This is ", b("bold"), " text.")
#> [1] "<p>This is <b>bold</b> text.</p>"
rm(list = names(html), envir = environment())

##Exercise1. 
mysummary=function(otype){
  funclist=as.list(methods("summary"))
  names(funclist)=gsub("summary.","",as.character(methods("summary")))
  if(otype %in% names(funclist)){
    function(x){
      get(funclist[[otype]])(x)
    }
  }
}

#2.Which of the following commands is equivalent to with(x, f(z))?
# x$f(x$z).
# f(x$z).
# x$f(z).
# f(z).
#A: It depends. f in the list x first look for z in x, if not found , look up to global 
x=list(f=function(x){print(x)},z="haha")
as.environment(x) #list could be a different env from global

################
###Case Study###
################
midpoint <- function(f, a, b) {
  (b - a) * f((a + b) / 2) #矩形面积
}

trapezoid <- function(f, a, b) {
  (b - a) / 2 * (f(a) + f(b)) #梯形面积
}

midpoint(sin, 0, pi)
#> [1] 3.141593
trapezoid(sin, 0, pi)
#> [1] 1.923671e-16

###Above shows the approximation of area is not accurate enough
###So lets break up the range into smaller pieces
### composite integration. I’ll implement it using two new functions:

midpoint_composite <- function(f, a, b, n = 10) {
  points <- seq(a, b, length = n + 1)
  h <- (b - a) / n

  area <- 0
  for (i in seq_len(n)) {
    area <- area + h * f((points[i] + points[i + 1]) / 2)
  }
  area
}

trapezoid_composite <- function(f, a, b, n = 10) {
  points <- seq(a, b, length = n + 1)
  h <- (b - a) / n

  area <- 0
  for (i in seq_len(n)) {
    area <- area + h / 2 * (f(points[i]) + f(points[i + 1]))
  }
  area
}

midpoint_composite(sin, 0, pi, n = 10)
#> [1] 2.008248
midpoint_composite(sin, 0, pi, n = 100)
#> [1] 2.000082
trapezoid_composite(sin, 0, pi, n = 10)
#> [1] 1.983524
trapezoid_composite(sin, 0, pi, n = 100)

####Now we see both functions are quite duplicated in code
#the difference actually lie in the for loop where it calculates the area according to specific rule
composite <- function(f, a, b, n = 10, rule) {
  points <- seq(a, b, length = n + 1)

  area <- 0
  for (i in seq_len(n)) {
    area <- area + rule(f, points[i], points[i + 1])
    #Here rule is either function midpoint or trapezoid defined early at start.
  }

  area
}

###Since rules could be replaced, the integration allows trying different rules
simpson <- function(f, a, b) {
  (b - a) / 6 * (f(a) + 4 * f((a + b) / 2) + f(b))
  ##(2*midpoint-rectangle+trapezoid)/3
}

boole <- function(f, a, b) {
  pos <- function(i) a + i * (b - a) / 4
  fi <- function(i) f(pos(i))

  (b - a) / 90 *
    (7 * fi(0) + 32 * fi(1) + 12 * fi(2) + 32 * fi(3) + 7 * fi(4))
}


###these rules are all childs of newton-cotes rules
newton_cotes <- function(coef, open = FALSE) {
  n <- length(coef) + open

  function(f, a, b) {
    pos <- function(i) a + i * (b - a) / n
    points <- pos(seq.int(0, length(coef) - 1))

    (b - a) / sum(coef) * sum(f(points) * coef)
  }
}

boole <- newton_cotes(c(7, 32, 12, 32, 7))
milne <- newton_cotes(c(2, -1, 2), open = TRUE)
composite(sin, 0, pi, n = 10, rule = milne)

rules=list(boole,milne,midpoint,trapezoid,simpson)
#Exercise 2: The trade-off between integration rules is that more complex rules are slower to compute, but need fewer pieces. For sin() in the range [0, π], determine the number of pieces needed so that each rule will be equally accurate. Illustrate your results with a graph. How do they change for different functions? sin(1 / x^2) is particularly challenging.

##PAY ATTENTION TO = , <- and -> they are different!!:
snm=c("asdf","dsf","")
any(nonames=sm=="");nonames;  # TRUE ; object 'nonames' not found
any(nonames->sm=="");nonames; # object 'nonames' not found
any(nonames<-snm=="");nonames;# TRUE ; FALSE FALSE  TRUE
#-> is typically used as: value -> x
#The operators <- and = assign into the environment in which they are evaluated
#The operator <- can be used anywhere, whereas the operator = is only allowed at the top level, which means it is not allowed in control structures like if
#use = will apply precedence i.e.: x <- y = 5#Error (x<-y) =5, it`s actually `=`(`<-`(x, y), 5)
median(x = 1:10)
x   
## Error: object 'x' not found
#x is declared within the scope of the function, so it does not exist in the user workspace
###SUMMARY: x<-value can live out side of judge sentences while x=value cannot!!!

###Greatly written##
namedlist=function(...){
  result=list(...)
  #sapply(substitute(list(a="ff",1)),deparse) this step convert all vector with assigned name
  #so all we have to do is find out which one doesnt have a name and assign it.
  lnames=sapply(substitute(list(...)),deparse)[-1] #remove "list" in the vector
  if(is.null(nm<-names(result))) nm<-lnames
  if (any(nonames <- nm=="")) nm[nonames] <- lnames[nonames]
  setNames(result,nm)
}
rules=namedlist(milne,boole,midpoint,trapezoid)
plotnVSarea=function(func,n,rules){
  require(reshape2)
  require(ggplot2)
  df=list()
  for (rule in names(rules)){
    df[[rule]]=sapply(seq_len(n),function(x) composite(func, 0, pi, n = x,rule=rules[[rule]]))
  }
  df$npieces=seq_len(n)
  df=as.data.frame(df)
  plot(x=seq_len(n))
  npieces=which.min(apply(df[,-dim(df)[2]],1,sd))
  df=melt(df,id="npieces")
  ggplot(df,aes(x=npieces,y=value,fill=variable,color=variable))+geom_point(pch=19)+theme_bw()
  cat("The number of pieces is: ",npieces, "to make rule sd minimized\n")
  return(npieces)
}
```
Functionals

```{r Funtionals}
#i.e.: lapply, apply
# The complement to a closure is a functional, a function that takes a function as an input and returns a vector as output
randomise <- function(f) f(runif(1e3))
randomise(mean)
#> [1] 0.5096054
randomise(mean)
#> [1] 0.5123963
randomise(sum)
#> [1] 491.1766

###Common use of functionals: 
#1 replace for loop to improve expressiveness
#2 using functionals will not always produce the fastest code. Instead, it helps you clearly communicate and build tools that solve a wide range of problems.

##################
##Sth about Loop##
##################
#1.loop over the elements: for (x in xs)
#2.loop over the numeric indices: for (i in seq_along(xs))
#3.loop over the names: for (nm in names(xs))

#first is slow: output is usually extending the vector: res<-c(res,x)
#second is better by: create the space at begining: res<-numeric(length(??)),then loop through vector



##################################
#Vector output: sapply and vapply#
##################################
#vapply() is more verbose, but gives more informative error messages and never fails silently. It is better suited for use inside other functions
vapply(list(), is.numeric, logical(1))
#> logical(0)

#####################################
###Multiple Inputs: Map and mapply###
#####################################
# Generate some sample data
xs <- replicate(5, runif(10), simplify = FALSE)
ws <- replicate(5, rpois(10, 5) + 1, simplify = FALSE)
#unweighted means:
unlist(lapply(xs, mean))

#while weighted means are calculated as: weighted.mean(xs[[i]], ws[[i]])
#so lapply should loop the seq_along(xs)
unlist(lapply(seq_along(xs), function(i) {
  weighted.mean(xs[[i]], ws[[i]])
}))

#Worked But clumsy, Map is better as a variant of lapply
unlist(Map(weighted.mean,xs,ws))
#NOTE: lapply(data,func), Map(func,data1,data2...)
#Map is equivalent to 
stopifnot(length(xs) == length(ws))
out <- vector("list", length(xs))
for (i in seq_along(xs)) {
  out[[i]] <- weighted.mean(xs[[i]], ws[[i]])
}

##it could also divide complicated lapply function to two steps to ease debuging
mtmeans <- lapply(mtcars, mean)
mtmeans[] <- Map(`/`, mtcars, mtmeans)

# In this case, equivalent to
mtcars[] <- lapply(mtcars, function(x) x / mean(x))
#If some of the arguments should be fixed and constant, use an anonymous function:

Map(function(x, w) weighted.mean(x, w, na.rm = TRUE), xs, ws)

####Mapply
#Map is equivalent to mapply with simplify=F, and is more recommended
#mapply has the MoreArgs argument that takes a list of extra arguments that will be supplied, as is, to each call. This breaks R’s usual lazy evaluation semantics, and is inconsistent with other functions.

#############################
##Rolling computations######
#############################
#rollmean to smooth
#n is the number of points it`s gonna come across to compute mean
rollmean <- function(x, n) {
  out <- rep(NA, length(x))

  offset <- trunc(n / 2)
  for (i in (offset + 1):(length(x) - n + offset + 1)) {
    out[i] <- mean(x[(i - offset):(i + offset - 1)])
  }
  out
}
x <- seq(1, 3, length = 10) + runif(10)
plot(x)
lines(rollmean(x, 5), col = "blue", lwd = 2)
###Note! use debug(rollmean);rollmean(x,5) to see value changes
lines(rollmean(x, 10), col = "red", lwd = 2)

##rewrite rollmean
rollapply <- function(x, n, f, ...) {
  out <- rep(NA, length(x))

  offset <- trunc(n / 2)
  for (i in (offset + 1):(length(x) - n + offset + 1)) {
    out[i] <- f(x[(i - offset):(i + offset)], ...)
  }
  out
}
plot(x)
lines(rollapply(x, 5, median), col = "red", lwd = 2)

#rewrite again! effectively the same as the implementation in zoo::rollapply()
rollapply <- function(x, n, f, ...) {
  offset <- trunc(n / 2)
  locs <- (offset + 1):(length(x) - n + offset + 1)
  num <- vapply(
    locs, 
    function(i) f(x[(i - offset):(i + offset)], ...),
    numeric(1)
  )

  c(rep(NA, offset), num)
}

######################
##Parallelisation#####
######################
#lapply is order independent:
lapply3 <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in sample(seq_along(x))) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
unlist(lapply(1:10, sqrt))
#>  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751
#>  [8] 2.828427 3.000000 3.162278
unlist(lapply3(1:10, sqrt))
#>  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751
#>  [8] 2.828427 3.000000 3.162278

##That makes parallelization possible
##This is what parallel::mclapply() (and parallel::mcMap()) does. (These functions are not available in Windows, but you can use the similar parLapply() with a bit more work. See parallelise for more details.)

###Exercise2: Why is using sapply() to get the class() of each element in a data frame dangerous?
#It wont warn you if class attr has length >2

###Exercise3:
#repeat runing a function for 100times!
trials <- replicate(
  100, 
  t.test(rpois(10, 10), rpois(7, 10)),
  simplify = FALSE
)
test=sapply(trials, `[[`,"p.value")
  
###Exercise5:Implement a version of lapply() that supplies FUN with both the name and the value of each component.
bapply=function(inputlist,f,...){
  if(is.null(names(inputlist))) stop("No names in the list")
  for (i in seq_along(inputlist)){
    f(i,...)
    f(names(inputlist)[i],...)
  }
}

###???Exercise6: Implement a combination of Map() and vapply() to create an lapply() variant that iterates in parallel over all of its inputs and stores its outputs in a vector (or a matrix). What arguments should the function take?

###???Exercise7:Implement mcsapply(), a multicore version of sapply(). Can you implement mcvapply(), a parallel version of vapply()? Why or why not?


#####################################
###Functionals for matrices or dfs###
#####################################
aperm() #put high-dim array  back in right order
sweep() #apply to a matrix by row or col, and func with same length vector iteratively
    x <- matrix(rnorm(20, 0, 10), nrow = 4)
    x1 <- sweep(x, 1, apply(x, 1, min), `-`) #
    x2 <- sweep(x1, 1, apply(x1, 1, max), `/`)
outer(1:3,1:10,"*")
#outer(行, 列,"*"), 行元素1与所有列进行"*" 然后行2....

rapply() #recursively apply function to list elements
myFun <- function(x){
    if (is.character(x)){
    return(paste(x,"!",sep=""))
    }
    else{
    return(x + 1)
    }
}

#A nested list structure
l <- list(a = list(a1 = "Boo", b1 = 2, c1 = "Eeek"), 
          b = 3, c = "Yikes", 
          d = list(a2 = 1, b2 = list(a3 = "Hey", b3 = 5)))
#Result is named vector, coerced to character           
rapply(l,myFun)
#Result is a nested list like l, with values altered
rapply(l, myFun, how = "replace")

#################
###Group apply###
#################
tapply(x,INDEX,FUN,simplify)  
##apply that allows "ragged" arrays where each row could have different num of cols
##kinda like aggregate which is actually tapply at cores

pulse <- round(rnorm(22, 70, 10 / 3)) + rep(c(0, 5), c(10, 12))
group <- rep(c("A", "B"), c(10, 12))
tapply(pulse, group, length)
#machanism:
data=split(pulse, group)
sapply(data, length)


by() ##usually used when tapply is not able to handle
######Compare tapply and by###############
#similarity between tapply and by:
ct <- tapply(iris$Sepal.Width , iris$Species , summary )
cb <- by(iris$Sepal.Width , iris$Species , summary )
#difference:
tapply(iris, iris$Species, summary ) #Error arguments must have same length
#Here tapply cant apply to data frame, dim(iris) and iris$Species are different
by(iris, iris$Species, summary ) #worked like a charm
#Worked by subset dataframe by iris$Species and apply function to sub-dataframe

######Compare tapply and aggregate#########
#second argument of aggregate must be a list while tapply can (not mandatory) be a list and that the output of aggregate is a data frame while the one of tapply is an array.

#######Compare by and aggregate##########
#
ag1 <- aggregate(cbind(Ozone, Temp) ~ Month, data = airquality, mean)
by(airquality[c("Ozone", "Temp")], airquality$Month, mean, na.rm = TRUE) ##Error cuz mean func doesnt apply to function

###Summary in input output###
# Base function   Input   Output   plyr function 
# ---------------------------------------
# aggregate        d       d       ddply + colwise 
# apply            a       a/l     aaply / alply 
# by               d       l       dlply 
# lapply           l       l       llply  
# mapply           a       a/l     maply / mlply 
# replicate        r       a/l     raply / rlply 
# sapply           l       a       laply 


##################
####plyr package##
##################
#to make base functionals consistent

###Exercise2: There’s no equivalent to split() + vapply(). Should there be? When would it be useful? Implement one yourself.
pulse <- round(rnorm(22, 70, 10 / 3)) + rep(c(0, 5), c(10, 12))
group <- rep(c("A", "B"), c(10, 12))
data=split(pulse, group)
sapply(data, length) #worked even data is ragged
vapply(data,as.character,FUN.VALUE = character(10)) #not worked,FUN[[2]] is 12 length
vapply(data, is.numeric,FUN.VALUE = logical(1)) # worked cuz fun return a logical result each loop
vapply(data, is.numeric,FUN.VALUE = numeric(1)) #worked cuz logical<numeric<double<complex
vapply(data,is.numeric,character(1))
#not worked, cuz coercion to character is not in vapply coercion table 
vapply(data, function(x){if(is.numeric(x)) as.character(is.numeric(x))},FUN.VALUE = character(1)) 
#wored, cuz func coerced result to character that matches FUN.VALUE
data$A=c(data$A,c(1,2))
vapply(data,as.character,FUN.VALUE = character(12)) #worked cuz each loop result length is 12
#Summary: vapply applies only to unragged data and is not suitable for character results when coercion is needed for results generated from func

###Exercise3: Implement a pure R version of split(). (Hint: use unique() and subsetting.) Can you do it without a for loop?
split(pulse, group) #split vector

df=data.frame(p=pulse,g=group)
split(df,group) #split dataframe

mysplit=function(data,group){
  if(is.data.frame(data)==FALSE) tapply(data,group,`[`)
  else by(data,group,`[`)
}
##??how not to use for loop???

#DHDC08P1_0304:1:2108:11503:92934#AGTCAACA


########################
##Manipulating list#####
########################
#Reduce :also known as combine step, fold step.
l <- replicate(5, sample(1:10, 15, replace = T), simplify = FALSE) #simplify =FALSE to generate list
intersect(intersect(intersect(intersect(l[[1]], l[[2]]),
  l[[3]]), l[[4]]), l[[5]])
Reduce(intersect, l)
#compute first two args, then result with third, then result with fourth


############################
###Predicated functionals###
############################
# Filter() only return elements match the predicate,wont return data frame with specific col match predicate
# Find() return first element match or last element with right =TRUE
# Position() return pos as above

###Exercise1: Why isn’t is.na() a predicate function? What base R function is closest to being a predicate version of is.na()?
#is.na is not a predicate cuz predicate returns a single T or F, is.na could return a vector of T,F
#anyNA

###Exercise2: Use Filter() and vapply() to create a function that applies a summary statistic to every numeric column in a data frame.
df <- data.frame(x = 1:3, y = c("a", "b", "c"),z=2:4)
mysummary=function(df){
  summary(Filter(is.numeric,df))
}

###Exercise4:Implement Any(), a function that takes a list and a predicate function, and returns TRUE if the predicate function returns TRUE for any of the inputs. Implement All() similarly.
myany=function(inputlist,f){
  TRUE %in% lapply(inputlist,f)
}
myall=function(inputlist,f){
  !(FALSE %in% lapply(inputlist,f))
}

###???Exercise5:Implement the span() function from Haskell: given a list x and a predicate function f, span returns the location of the longest sequential run of elements where the predicate is true. (Hint: you might find rle() helpful.)

##############################
###mathematical functionals###
##############################
# integrate() finds the area under the curve defined by f()
# uniroot() finds "first" where f() hits zero
# optimise() finds the location of lowest (or highest) value of f()

uniroot(sin, c(2,2*pi)) #find first x where sin(x) is 0
optimise(sin, c(0, 2 * pi),maximum = T) #find x where sin(x) is max

#optimise is widely used for computing ML of things
#First, we create a function factory that, given a dataset, returns a function that computes the negative log likelihood (NLL) for parameter lambda. In R, it’s common to work with the negative since optimise() defaults to finding the minimum.

poisson_nll <- function(x) {
  n <- length(x)
  sum_x <- sum(x)
  function(lambda) {
    n * lambda - sum_x * log(lambda) # + terms not involving lambda
  }
}
x1 <- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)
x2 <- c(6, 4, 7, 3, 3, 7, 5, 2, 2, 7, 5, 4, 12, 6, 9)
nll1 <- poisson_nll(x1)
nll2 <- poisson_nll(x2)

optimise(nll1, c(0, 100))$minimum
#> [1] 32.09999
optimise(nll2, c(0, 100))$minimum
#> [1] 5.466681

###optim(): a generalisation of optimise() that works with more than one dimension

###Exercies1: Implement arg_max(). It should take a function and a vector of inputs, and return the elements of the input where the function returns the highest value. For example, arg_max(-10:5, function(x) x ^ 2) should return -10. arg_max(-5:5, function(x) x ^ 2) should return c(-5, 5). Also implement the matching arg_min() function.
arg_max=function(x,f){
  res=f(x)
  x[which(res==max(res))]
}

###Exercise2: Challenge: read about the fixed point algorithm. Complete the exercises using R.
#fixed point: A number x is called a fixed point of a function f if x satisfies the equation f(x) = x
fixedPoints=function(f,...){
  fclosure=function(lambda){
      abs(f(lambda)-lambda) #lambda is the guess
  }
  optimise(fclosure,...)$minimum
}

#similarly: square root function could be explained as: find minimal x where sqrt(x)=~x
mysquaureroot=function(x){
  fclosure=function(lambda){
    abs(x/lambda-lambda) #lambda is the guess
  }
  optimise(fclosure,c(0,x))$minimum
}

#####################################
####Loops that better left as is#####
#####################################
#1. Modifying in place
#If you need to modify part of an existing data frame, it’s often better to use a for loop. 
#2. Recursive relationships
#It’s hard to convert a for loop into a functional when the relationship between elements is not independent, or is defined recursively.

#eliminate while loop
i <- 0
while(TRUE) {
  if (runif(1) > 0.9) break
  i <- i + 1
}
#can turn into:
i <- rgeom(1, 0.1)
#the while simply mean the success in each trial is 0<prob<0.1

#################
###Case study####
#################
# take a simple building block and make it powerful and general.
# Project : add function
# This function take two args and return values that are not NA
rm_na <- function(x, y, identity) {
  if (is.na(x) && is.na(y)) {
    identity
  } else if (is.na(x)) {
    y
  } else {
    x
  }
}  
### It is combined with add to dealwith NA inputs  
add <- function(x, y, na.rm = FALSE) {
  if (na.rm && (is.na(x) || is.na(y))) rm_na(x, y, 0) else x + y
}

###lets extend add to multiple inputs
r_add <- function(xs, na.rm = TRUE) {
  Reduce(function(x, y) add(x, y, na.rm = na.rm), xs)
}
r_add(c(1, 4, 10))
#> [1] 15
#Note the r_add didn`t test case that xs is just length 1 or 0
r_add(NA, na.rm = TRUE)
#> [1] NA
r_add(numeric())
#> NULL
r_add(1)  #in this con,xs is only length 1 and it still worked .We can tell it`s because of 
#Reduce(),  If we give Reduce() a length one vector, it doesn’t have anything to reduce, so it just returns the input. If we give it an input of length zero, it always returns NULL. 

###simply add init arg
r_add <- function(xs, na.rm = TRUE) {
  Reduce(function(x, y) add(x, y, na.rm = na.rm), xs, init = 0)
}
r_add(c(1, 4, 10))
#> [1] 15
r_add(NA, na.rm = TRUE)
#> [1] 0
r_add(numeric())
#> [1] 0

###Note add is not vectorised, lets make it to be so
#vectorise by Map or vapply
v_add1=function(x,y,na.rm=F){
  stopifnot(length(x)==length(y),is.numeric(x),is.numeric(y)) #pay attention to the grammer
  if(length(x)==0 ||length(y)==0) return(numeric())
  simplify2array(
    Map(add(na.rm=na.rm),x,y)
  )
}

v_add2=function(x,y,na.rm=F){
  stopifnot(length(x)==length(y),is.numeric(x),is.numeric(y)) #pay attention to the grammer
  vapply(seq_along(x),function(i){add(x[i],y[i],na.rm=na.rm)},numeric(1))
}

###variant of add: Cumulative sum
c_add <- function(xs, na.rm = FALSE) {
  Reduce(function(x, y) add(x, y, na.rm = na.rm), xs,
    accumulate = TRUE)
}
#by setting accumulate=T, it print out result of every combine
#This is equivalent to cumsum().

###Exercise1: Implement smaller and larger functions that, given two inputs, return either the smaller or the larger value. Implement na.rm = TRUE: what should the identity be? (Hint: smaller(x, smaller(NA, NA, na.rm = TRUE), na.rm = TRUE) must be x, so smaller(NA, NA, na.rm = TRUE) must be bigger than any other value of x.) Use smaller and larger to implement equivalents of min(), max(), pmin(), pmax(), and new functions row_min() and row_max().
subNA=function(x,y,identity){
  if (is.na(x) && is.na(y)) {
    identity
  } else if (is.na(x)) {
    y
  } else {
    x
  }
}

smaller=function(x,y,na.rm=F){
  if(na.rm && (is.na(x)||is.na(y))) return(subNA(x,y,Inf))
  else if(is.na(x)||is.na(y)){
    return(NA)
  }
  if(x>y) return(y)
  else return(x)
}

larger=function(x,y,na.rm=F){
  if(na.rm && (is.na(x)||is.na(y))) return(subNA(x,y,-Inf))
  else if(is.na(x)||is.na(y)){
    return(NA)
  }
  if(x>y) return(x)
  else return(y)
}

min=function(...,na.rm=F){
  elements=c(...)
  Reduce(function(x,y){smaller(x,y,na.rm=na.rm)},elements)
}
max=function(...,na.rm=F){
  elements=c(...)
  Reduce(function(x,y){larger(x,y,na.rm=na.rm)},elements)
}

pmin=function(...,na.rm=F){
  inputlist=list(...)
  #Here I defined recycling of vector, maybe it is better not to recycle to prevent extra silent bugs
  if(all(sapply(inputlist,length)==1)){
    min(unlist(inputlist),na.rm=na.rm)
  }else{
    lens=vapply(seq_along(inputlist),function(x){length(inputlist[[x]])},numeric(1))
    inputlist=lapply(inputlist,rep,length=max(lens))
    simplify2array(
      apply(as.data.frame(inputlist),1,min,na.rm=na.rm)
    )
  }  
}


pmax=function(...,na.rm=F){
  inputlist=list(...)
  #Here I defined recycling of vector, maybe it is better not to recycle to prevent extra silent bugs
  if(all(sapply(inputlist,length)==1)){
    max(unlist(inputlist),na.rm=na.rm)
  }else{
    lens=vapply(seq_along(inputlist),function(x){length(inputlist[[x]])},numeric(1))
    inputlist=lapply(inputlist,rep,length=max(lens))
    simplify2array(
      apply(as.data.frame(inputlist),1,max,na.rm=na.rm)
    )
  }  
}

row_min=function(data){
  apply(data,1,min)
}

row_max=function(data){
  apply(data,1,max)
}

###Exercise2: Create a table that has and, or, add, multiply, smaller, and 
###larger in the columns and binary operator, reducing variant, vectorised 
###variant, and array variants in the rows.
###a. Fill in the cells with the names of base R functions that perform each of the roles.
###b. Compare the names and arguments of the existing R functions. How consistent are they? How could ###   you improve them?
# ###c. Complete the matrix by implementing any missing functions.
# a.              and   or  add   multiply   smaller   larger
# binary          &&    ||    +       *                   
# reducing var    all   any  sum     prod      min       max
# vectorised var  &     |     +       *        pmin      pmax
# array var                   +       *

#extra notes:
library(stringr)
library(ggplot2)
randomise <- function(f) f(runif(1e3))
randomise(mean)
#> [1] 0.5115665
randomise(mean)
#> [1] 0.503939
randomise(sum)

replicate(500,randomise(sum)) %>%
  data.frame(x = .) %>%
  ggplot(aes(x = x)) + geom_density()

###??Exercise3: How does paste() fit into this structure? What is the scalar binary function that underlies paste()? What are the sep and collapse arguments to paste() equivalent to? Are there any paste variants that don’t have existing R implementations?
#paste(c(1,3),c(4,1),sep="-",collapse="+") : "1-4+3-1"
#binary is "+"? 
#sep is used in a Map function
#collapse is used in a Reduce function to apply "+" to every two results of Map function
#paste seems to be functional for all variants like vectorise, array, list, data.frame, etc

```
Function Operators
```{r function operators}
#########
###FOs###
#########
### A function operator is a function that takes one (or more) functions as input and returns a function as output. The result function act like a wrap of input functions
#Compared to closure, it need functions as input while closure don`t neccessarily need
#Compared to functionals, it returns a function rather than a data type
compact1 <- function(x) Filter(Negate(is.null), x)
compact2 <- partial(Filter, Negate(is.null))

##################
##Behavioural FO##
##################
#Behavioural FOs leave the inputs and outputs of a function unchanged, but add some extra behaviour. 
###Example function with three behaviours:
# Add a delay to avoid swamping a server with requests.
# Print to console every n invocations to check on a long running process.
# Cache previous computations to improve performance.
download_file <- function(url, ...) {
  download.file(url, basename(url), ...)
} #a wrapper of utils::download.file()
lapply(urls, download_file)

###To implement 3 behaviours:
i <- 1
for(url in urls) {
  i <- i + 1
  if (i %% 10 == 0) cat(".") #cat . for every 10 urls to show its still working
  Sys.delay(1)  #set delay for not harming server
  download_file(url)
}
#However, it is hard to understand the code without comment

###By create a FO we could encapsulate each behaviour . i.e:
lapply(urls, dot_every(10, delay_by(1, download_file)))

delay_by <- function(delay, f) {
  function(...) {
    Sys.sleep(delay)
    f(...)
  }
}
system.time(runif(100))
#>    user  system elapsed 
#>   0.001   0.000   0.000
system.time(delay_by(0.1, runif)(100))
#>    user  system elapsed 
#>   0.000   0.000   0.101

dot_every <- function(n, f) {
  i <- 1
  function(...) {
    if (i %% n == 0) cat(".")
    i <<- i + 1
    f(...)
  }
}

### arg f is better to be left as last argument. otherwise:
download <- dot_every(delay_by(download_file, 1), 10)
#would be very hard to follow
#better:
lapply(urls, dot_every(10, delay_by(1, download_file)))

####################
####Memoisation#####
####################
#A memoised function can run much faster because it stores all of the previous inputs and outputs, using more memory
#A realistic use of memoisation is computing the Fibonacci series. The Fibonacci series is defined recursively: the first two values are 1 and 1, then f(n) = f(n - 1) + f(n - 2)
#naive version of R implementation is slow cuz it computes f(n-2) f(n-1) duplicated times
fib <- function(n) {
  if (n < 2) return(1)
  fib(n - 2) + fib(n - 1)
}
system.time(fib(23))
#>    user  system elapsed 
#>   0.125   0.006   0.132
system.time(fib(24))
#>    user  system elapsed 
#>   0.194   0.003   0.196

###Now lets memoise the function!
fib2 <- memoise(function(n) {
  if (n < 2) return(1)
  fib2(n - 2) + fib2(n - 1)
})
system.time(fib2(23))
#>    user  system elapsed 
#>   0.004   0.000   0.004
system.time(fib2(24))
#>    user  system elapsed 
#>   0.001   0.000   0.000

###machanism of memoise is just store key and result into a cache list
runifm <- memoise(runif)
#this runifm is actually a function that do two conditional operation:
#1. if digest(list(...)) is in cache list, just get the result(prevent duplicated computation)
#2. if not in cache list, use the "runif" func stored in the closure to compute,then set the value with cache
runifm(5)
#> [1] 0.5374603 0.3466054 0.3079437 0.3631236 0.9511340
runifm(5)
#> [1] 0.5374603 0.3466054 0.3079437 0.3631236 0.9511340

###Finally
download <- dot_every(10, memoise(delay_by(1, download_file)))

##################################
##Capturing function invocations##
##################################
#it can be hard to see what’s going on inside of functionals
#we can use FOs to peer behind the curtain with tee()
ignore <- function(...) NULL
#use tee , a FO to show what`s going on inside functionals
tee <- function(f, on_input = ignore, on_output = ignore) {
  function(...) {
    on_input(...)
    output <- f(...)
    on_output(output)
    output
  }
}
#i.e:
g <- function(x) cos(x) - x
zero <- uniroot(g, c(-5, 5))
show_x <- function(x, ...) cat(sprintf("%+.08f", x), "\n")
zero <- uniroot(tee(g, on_input = show_x), c(-5, 5))
#what tee is doing is simply add a layer of show_x before g(x) 
#So the on_input,on_output could display input arg for g(x) and output of g(x)
zero <- uniroot(tee(g, on_output = show_x), c(-5, 5))

###In order to catch the output of func on_input , on_output,we actually have to 
#store them in a list.
#to maintain the list unchanged, we have to make the list a global var in a closure:
remember <- function() {
  memory <- list()
  f <- function(...) {
    # This is inefficient!
    memory <<- append(memory, list(...))
    invisible()
  }

  structure(f, class = "remember")
}
as.list.remember <- function(x, ...) {
  environment(x)$memory
}
#the print.remeber is inevitable
print.remember <- function(x, ...) {
  cat("Remembering...\n")
  str(as.list(x))
} #otherwise type a remember class will return a closure and append NULL arguments

###test remember func
locs <- remember()  #create a list of memory that append itself args foreach looop
vals <- remember()
zero <- uniroot(tee(g, locs, vals), c(-5, 5))
x <- unlist(as.list(locs))
error <- unlist(as.list(vals))
plot(x, type = "b"); abline(h = 0.739, col = "grey50")
plot(error, type = "b"); abline(h = 0, col = "grey50")

############
##Laziness##
############
#The FO we ve seen so far is commonly:
funop <- function(f, otherargs) {
  function(...) {
    # maybe do something
    res <- f(...)
    # maybe do something else
    res
  }
}
#One problem is that f()  is lazily evaluated, which means it may have changed before apply and evaluate
delay_by <- function(delay, f) {
  function(...) {
    Sys.sleep(delay)
    f(...)
  }
}
funs <- list(mean = mean, sum = sum)
funs_m <- lapply(funs, delay_by, delay = 0.1)
###since R 3.2 this lazy evaluation seems not to be a problem now

###Exercise1: Write a FO that logs a time stamp and message to a file every time a function is run.
timestamp=function(logfile,f){
   function(...){
     result=f(...)
     cat(date(),"\n",file=logfile,append=T)
     result
   }  
}

###Exercise2: What does the following function do? What would be a good name for it?
f <- function(g) {
  force(g)
  result <- NULL
  function(...) {
    if (is.null(result)) {
      result <<- g(...)
    }
    result
  }
}
runif2 <- f(runif)
runif2(5)
#> [1] 0.9740204 0.1269874 0.2954060 0.2944669 0.6048259
runif2(10)
#> [1] 0.9740204 0.1269874 0.2954060 0.2944669 0.6048259
#Answer: this function shall be called runOnce

###Exercise3 : defined a delay_by that instead ensures a certain time elapsed after function call
delay_by <- function(delay, f) {
  time=NULL
  function(...) {
    if( is.null(time)|| as.double(Sys.time()-time)>=delay){
      f(...)
      time<<-Sys.time()
    }else{
      Sys.sleep(delay-as.double(Sys.time()-time))
      f(...)
      time<<-Sys.time()
    }
  }
} #考虑三个逻辑：第一次运行，延误超时后的运行和不超时的运行

delay_by2 <- function(delay, f)
{
  delay_until <- Sys.time()

  function(...)
  {
    if(delay_until - Sys.time() > 0) {
      Sys.sleep(delay_until - Sys.time())
    }

    res <- f(...)
    delay_until <<- Sys.time() + delay
    res
  }  
} #BETTER!!!考虑两个逻辑 满足delay和不满足delay:
  #满足delay: 要延迟的时间小于当前时间（第一次运行和超时运行）
  #不满足delay: 要延迟到的时间大于当前时间,程序拖延到延迟时间

delay_by3 <- function(delay, f)
{
  executime <- 0
  #如果换成<-Sys.time(),执行时间就不对了,因为第一次执行并不是Sys.time
  #得到经验:数值,时间的初始值最好是0
  function(...)
  {
    if(Sys.time()-executime < delay) {
      print(delay-(Sys.time()-executime))
      Sys.sleep(delay-(Sys.time()-executime))
    }#距离上次call时间在delay内,则delay
    res <- f(...)
    executime <<- Sys.time()
    res
  }  
}#但是注意Sys.time()-executime < delay ->Sys.time()< delay+executime
 #在executime=0的时候,如果delay 异常大,大过现在时间的话,会变成True
 #但如果变换式子为Sys.time()-delay<executime,则可设初始executime为-inf,则初始必false
 #Sys.time()-delay< -(Inf)
 #在delay2 func中delay_until - Sys.time() > 0 ,在第一次运行时永不为true(Sys.time-Sys.time==0!>0)
delay_by3gai <- function(delay, f)
{
  executime <- -Inf
  #如果换成<-Sys.time(),执行时间就不对了,因为第一次执行并不是Sys.time
  #得到经验:数值,时间的初始值最好是0
  function(...)
  {
    if(Sys.time()- delay< executime) {
      print(delay-(Sys.time()-executime))
      Sys.sleep(delay-(Sys.time()-executime))
    }#距离上次call时间在delay内,则delay
    res <- f(...)
    executime <<- Sys.time()
    res
  }  
}

f=function(){print("Executed once");print(Sys.time());return(NULL)}
g<-delay_by(1,f);g();Sys.sleep(2);g()
#####Note: if 中的condition 不等式左右换位可有大不同.
#如何推导delay_until - Sys.time() > 0这个条件?
########## 考虑两个动态变化的时间点(数据)时,最好画两条线
#   establish    call      call2
# -----*-----------*--*----*---
#                  *----*
#       {         }{delay}
#{}{delay}的长度最长,第一次call时establish的时间短于或等于call的时间:time<-Sys.time;funciton(){if(time<=sys.time).... 也即time <=sys.time
#第二次call的时候call2的system.time>=call1time+delay,也即call1time+delay<=sys.time
#这样的话establish time就应该按照calltime+delay来取名,第一次establish time为sys.time of FO ,call之后为sys.time of closure+delay

###Exercies5: There are three places we could have added a memoise call: why did we choose the one we did?
delay_by <- function(delay, f) {
  function(...) {
    Sys.sleep(delay)
    f(...)
  }
}

dot_every <- function(n, f) {
  i <- 1
  function(...) {
    if (i %% n == 0) cat(".")
    i <<- i + 1
    f(...)
  }
}
download.file=function(x){cat("downloading");print(x);}
download_file <- function(url, ...) {
  download.file(url, ...)
}
urls=as.list(c(LETTERS[1:4],rep("E",20))) #duplicate E
urls2=as.list(c(LETTERS)) #non duplicates
download <- memoise(dot_every(10, delay_by(1, download_file)))
#download() is just like
download <- dot_every(10, memoise(delay_by(1, download_file)))
#begin doting at 10,difference is 26 secs
download <- dot_every(10, delay_by(1, memoise(download_file)))
#test by non duplicates
start=Sys.time()
test=lapply(urls2,download)
print(Sys.time()-start)
#test by duplicates
start=Sys.time()
test=lapply(urls,download)
print(Sys.time()-start)
#as.list(environment(download))$cache$keys()
###Answer: if there`s no duplicates in urls2: the first run of all three is the same
###         But, second run of the first two  would be different:
###download <- memoise(dot_every(10, delay_by(1, download_file))) would not perform dot_every
###download <- dot_every(10, memoise(delay_by(1, download_file))) would dot, but would not delay
###download <- dot_every(10, delay_by(1, memoise(download_file))) would dot and also delay
###         if there`s duplicates in urls: first run would be different:
###download <- memoise(dot_every(10, delay_by(1, download_file))) not dotting if dup happend before ###                                                   dotting start number,get dup res rather fast
###download <- dot_every(10, memoise(delay_by(1, download_file))) would dot, get dup res fast
###download <- dot_every(10, delay_by(1, memoise(download_file))) would dot and delay anyway

###IMPORTANT SUMMARY:momoise store f in its closure, if calculated once, f would never function again
###We choose the middle one cuz we want the dot happen while the delay does not if dup in urls

###Exercise6: Why is the remember() function inefficient? How could you implement it in more efficient way?
remember <- function() {
  memory <- list()
  f <- function(...) {
    # This is inefficient!
    memory <<- append(memory, list(...))
    invisible()
  }

  structure(f, class = "remember")
}
as.list.remember <- function(x, ...) {
  environment(x)$memory
}
print.remember <- function(x, ...) {
  cat("Remembering...\n")
  str(as.list(x))
}

ignore <- function(...) NULL
tee <- function(f, on_input = ignore, on_output = ignore) {
  function(...) {
    on_input(...)
    output <- f(...)
    on_output(output)
    output
  }
}
g <- function(x) cos(x) - x

###test:
locs <- remember()
vals <- remember()
start=Sys.time()
zero <- uniroot(tee(g, locs, vals), c(-5, 5))
print(Sys.time()-start)
x <- unlist(as.list(locs))
error <- unlist(as.list(vals))

##Here we can hardly see its inefficiency but my guess is it lies in the recopy of list every time ##remember called


###Exercise7: Why does the following code, from stackoverflow, not do what you expect?
# return a linear function with slope a and intercept b.
f <- function(a, b) function(x) a * x + b
# create a list of functions with different parameters.
fs <- Map(f, a = c(0, 1), b = c(0, 1))
#fs[[1]](3) :4
###This is historically wrong because of lazy evaluation, 
###so in the past we had to f=function(a,b){force(a);force(b);}
###But, this is no longer a problem now.

################
###Output FOs###
################
## modify the output of a function.
#two simple modification: Negate() and failwith()
#two fundamental modification: capture_it() and time_it() ,change what FO does

###Minor modifications
#base::Negate() and plyr::failwith()
#Negate takes a function that returns a logical vector like is.null ...
#compact that use negate function to remove all null elements from a list
Negate=function(f){
  force(f)
  function(...){!f(...)}
}
compact=function(xlist){
  Filter(Negate(is.null),xlist)
}

#plyr::failwith() make function that throws an error return a default value when got error
#by silent=quiet , it simply ignores all errors and return out
failwith <- function(default = NULL, f, quiet = FALSE) {
  force(f)
  function(...) {
    out <- default
    try(out <- f(...), silent = quiet)
    out
  }
}
##failwith() is useful in conjunction with functionals: it can complete the iteration and then find out what went wrong.
# If any model fails, all models fail to fit:
models <- lapply(datasets, glm, formula = y ~ x1 + x2 * x3)
# If a model fails, it will get a NULL value
models <- lapply(datasets, failwith(NULL, glm),
  formula = y ~ x1 + x2 * x3)

# remove failed models (NULLs) with compact
ok_models <- compact(models)
# extract the datasets corresponding to failed models
failed_data <- datasets

###Changing what a function does
capture_it <- function(f) {
  force(f)
  function(...) {
    capture.output(f(...))
  }
}
str_out <- capture_it(str)
str(1:10)
#>  int [1:10] 1 2 3 4 5 6 7 8 9 10
str_out(1:10)
#> [1] " int [1:10] 1 2 3 4 5 6 7 8 9 10"

time_it <- function(f) {
  force(f)
  function(...) {
    system.time(f(...))
  }
}
compute_mean <- list(
  base = function(x) mean(x),
  sum = function(x) sum(x) / length(x)
)
x <- runif(1e6)

# Previously we used an anonymous function to time execution:
# lapply(compute_mean, function(f) system.time(f(x)))

# Now we can compose function operators:
call_fun <- function(f, ...) f(...)
lapply(compute_mean, time_it(call_fun), x)

###Exercise2:The evaluate package makes it easy to capture all the outputs (results, text, messages, warnings, errors, and plots) from an expression. Create a function like capture_it() that also captures the warnings and errors generated by a function.
library(evaluate)

capture_all <- function(f) {
  force(f)
  function(...) {
    evaluate(f(...), stop_on_error = 0, keep_warning = TRUE,
             keep_message = TRUE)
  }
}

a <- capture_all(log)
log(-1)
a(-1)

###Exercise3:Create a FO that tracks files created or deleted in the working directory (Hint: use dir() and setdiff().) What other global effects of functions might you want to track?

track2 <- function(f)
{
  force(f)
  function(...)
  {
    dir_before <- dir(getwd())

    res <- f(...)

    dir_after <- dir(getwd())

    cat("Added", setdiff(dir_after, dir_before), sep=" ")
    cat("Removed", setdiff(dir_before, dir_after), sep=" ")

    res
  }
}

#############
##Input FOs##
#############
###IN MINOR WAY: partial function variant
#It is a function that has certain arguments “filled in” already. This is called “partial function application”, and is implemented by pryr::partial().

f <- function(a) g(a, b = 1)
#replaced with:
f <- partial(g, b = 1)

#This is useful when we had to simplify code that working with lists of functions
funs2 <- list(
  sum = function(...) sum(..., na.rm = TRUE),
  mean = function(...) mean(..., na.rm = TRUE),
  median = function(...) median(..., na.rm = TRUE)
)
#we can write:
library(pryr)
funs2 <- list(
  sum = partial(sum, na.rm = TRUE),
  mean = partial(mean, na.rm = TRUE),
  median = partial(median, na.rm = TRUE)
)

###IN MAJOR WAY: change input types
#base::Vectorize() converts a scalar function to a vector function, 
#i.e
sample(1:5, 5:3) #unvectorized
sample2 <- Vectorize(sample, "size", SIMPLIFY = FALSE) #vectorize the size argument of sample
#SIMPLIFY = FALSE to ensure that our newly vectorised function always returns a list. This is usually what you want
sample2(1:5,5:3) 

#splat() converts a function that takes multiple arguments to a function that takes a single list of arguments.
#i.e
splat <- function (f) {
  force(f)
  function(args) {
    do.call(f, args)
  }
}

###Very usefull if you invoke a function with varying arguments:
x <- c(NA, runif(100), 1000)
args <- list(
  list(x),
  list(x, na.rm = TRUE),
  list(x, na.rm = TRUE, trim = 0.1) #trim both tail 10% of data
)
lapply(args, splat(mean))

###plyr::colwise() converts a vector function to one that works with data frames:
plyr::colwise(median)(mtcars)

###Exercise1: Our previous download() function only downloads a single file. How can you use partial() and lapply() to create a function that downloads multiple files at once? What are the pros and cons of using partial() vs. writing a function by hand?
#It is the same course of turning a single input func into a list input func
download=function(url){cat("Url is :",url,"\n")}
urls=list(ur1="sdfasfd",ur2="dfsfa")
download2=function(urls){lapply(urls,download)}
download2=function(...){lapply(...,FUN=download)} 
download2=partial(lapply,FUN=download) #NOTE!! Here we must have "FUN=download"!!Otherwise the order is not right!!
#Anwser, I think the pros of partial is it clearly shows what function it is partial from
#But, it makes it less flexible in manipulating args of a closure.

###Exercise2: Read the source code for plyr::colwise(). How does the code work? What are colwise()’s three main tasks? How could you make colwise() simpler by implementing each task as a function operator? (Hint: think about partial().)
function (.fun, .cols = true, ...) 
{
    if (!is.function(.cols)) {
        .cols <- as.quoted(.cols)
        filter <- function(df) eval.quoted(.cols, df)
    }
    else {
        filter <- function(df) Filter(.cols, df)
    }
    dots <- list(...)
    function(df, ...) {
        stopifnot(is.data.frame(df))
        df <- strip_splits(df)
        filtered <- filter(df)
        if (length(filtered) == 0) 
            return(data.frame())
        out <- do.call("lapply", c(list(filtered, .fun, ...), 
            dots))
        names(out) <- names(filtered)
        quickdf(out)
    }
}
###Answer:
###A filter function is created. The function first tests to see if .cols is a function or not. If it is a function, it creates a filter function to apply .cols to a data frame. If not a function, it creates a filter function to filter a data frame based on the indexes given in .cols.
# The output function is created. The first process in the output function is to apply the filter function to the input data frame.
# The output function applies any extra arguments to the data.frame using the ... supplied.
# A data frame is returned.
###To simplify, the filter function could be partial() ed

###Exercise4: You’ve seen five functions that modify a function to change its output from one form to another. What are they? Draw a table of the various combinations of types of outputs: what should go in the rows and what should go in the columns? What function operators might you want to write to fill in the missing cells? Come up with example use cases.
###Answer:
#               scalar	     vector	      matrix	     data frame	   arg1, arg2, ...	list(args)
# scalar						
# vector	     Vectorize()					
# matrix				                                       df_matrix()		
# data frame		            colwise()	  matrix_df()			
# arg1, arg2, ...						
# list(args)					                                                 splat()

#################
##Combining FOs##
#################




```



