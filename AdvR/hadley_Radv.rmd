
OO field Guide
```{r OO field guide}
library(pryr)
#############
##base types#
#############
is.object(sum) #False

############
##s3 class##
############

#In S3, methods belong to functions, called generic functions, or generics for short. S3 methods do not belong to objects or classes. 
functiontype=function (f) 
{
    fexpr <- substitute(f)
    env <- parent.frame()
    fname <- if (is.name(fexpr)) 
        as.character(fexpr)
    else NULL
    if (is.primitive(f)) {
        c("primitive", if (is_internal_generic(primitive_name(f))) "generic")
    }
    else if (is_internal(f)) {
        c("internal", if (is_internal_generic(internal_name(f))) "generic")
    }
    else if (is(f, "standardGeneric")) {
        c("s4", "generic")
    }
    else if (is(f, "MethodDefinition")) {
        c("s4", "method")
    }
    else if (is(f, "refMethodDef")) {
        c("rc", "method")
    }
    else if (!is.null(fname) && is_s3_generic(fname, env)) {
        c("s3", "generic")
    }
    else if (!is.null(fname) && is_s3_method(fname, env)) {
        c("s3", "method")
    }
    else {
        c("function")
    }
}

##check S3 methods##
#check methods belong to a generic method in base package
methods(mean)
#list all generic methods of a given class:
methods(class="ts") #ts is an object in stats pacakge
#get source code of s3 method defined in packages other than base package
getS3method()
#Note!! is.Generic() is used only for S4 method

##create S3 class##
foo=structure(list(),class="foo")
class(foo)
inherits(foo,"foo")

#constructor function
foo <- function(x) {
  if (!is.numeric(x)) stop("X must be numeric")
  structure(list(x), class = "foo")
}

#generic function assign
f.a=function(x) "Class a"
a=structure(list(),class="a")

#Method dispatch
f <- function(x) UseMethod("f") 
#without this,method wouldnt be dispatched 
# UseMethod currently dispatches on the implicit class even for arguments that are not objects(base type), but the other means of dispatch do not.
f.a <- function(x) "Class a"
f.default <- function(x) "Unknown class"

##Group generics
?"groupGeneric"
#group generics dispatch on the oldClass not class for efficiency
#oldclass return and set class but are implemented in a diff way
#If the object does not have a class attribute, it has an implicit class, "matrix", "array" or the result of mode(x). (Functions oldClass and oldClass<- get and set the attribute, which can also be done directly.

##NextMethod
?NextMethod


#force R to call the wrong method
f.default(a) #this is only used to skip method dispatch
iclass <- function(x) {
  if (is.object(x)) {
    stop("x is not a primitive type", call. = FALSE)
  }

  c(
    if (is.matrix(x)) "matrix",
    if (is.array(x) && !is.matrix(x)) "array",
    if (is.double(x)) "double",
    if (is.integer(x)) "integer",
    mode(x)
  )
}
iclass(matrix(1:5))
#Here matrix is a non-S3 obj

####Excercise:
#4.Which base generic has the greatest number of defined methods?
baseobj=ls(envir = as.environment("package:base"))
baseobj=Filter(function(f){is.function(get(f))},baseobj)
checkgeneric=function(f){
  type=""
  #print(f)
  if(f=="F") return(NULL);
  if (pryr:::is_s3_generic(f)) {
       type= c("generic")
    }
    else if (pryr:::is_s3_method(f)) {
       type= c("method")
    }
  grepl("generic",type)
}
genericFuncs=Filter(checkgeneric,baseobj)
methodcount=sapply(genericFuncs,function(x){length(methods(x))})
which(methodcount==max(methodcount))

#6Internal generics donâ€™t dispatch on the implicit class of base types. 
#so functions with no $class attribute will not be dispatched internal methods

############
##s4 class##
############
# Methods still belong to functions, not classes, but:
# 
# Classes have formal definitions which describe their fields and inheritance structures (parent classes).
# 
# Method dispatch can be based on multiple arguments to a generic function, not just one.
# 
# There is a special operator, @, for extracting slots (aka fields) from an S4 object.

# All S4 related code is stored in the methods package. This package is always available when youâ€™re running R interactively, but may not be available when running R in batch mode. For this reason, itâ€™s a good idea to include an explicit library(methods) whenever youâ€™re using S4.


y <- c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8)
nLL <- function(lambda) - sum(dpois(y, lambda, log = TRUE))
fit <- mle(nLL, start = list(lambda = 5), nobs = length(y))
# Retrieve an S4 method, described later
ftype(nobs)
mle_nobs <- method_from_call(nobs(fit))
isS4(mle_nobs)
#> [1] TRUE
ftype(mle_nobs)
#> [1] "s4"     "method"

#nobs is the generic S4 func, nobs(fit) call method that belong to nobs.

##Check inheritance###
is(fit) #show parent classes
is(fit,"mle") #test inheritances

##check source code
showmethods(nobs) #object="ANY" means input not specified
getMethod(nobs,signature="ANY")
getMethod(nobs,signature="mle")

##list all S4 generics and S4 classes
getGenerics();getClasses();
##list all S4 methods
#showMethods(),by generics or by class, where=search() :globalEnv

###Define classes and create objs####
#define representation of class:
setClass()
#create obj
new()
# find the documentation for a class 
class?mle
#class name convention:
UpperCamelCase

###Three elements in S4:name, slots, contains: super
setClass("Person",
  slots = list(name = "character", age = "numeric"))
setClass("Employee",
  slots = list(boss = "Person"),
  contains = "Person")

alice <- new("Person", name = "Alice", age = 40)
john <- new("Employee", name = "John", age = 20, boss = alice)
#new() could be replaced with a constructor func

###If an S4 object contains (inherits from) an S3 class or a base type, it will have a special .Data slot which contains the underlying base type or S3 object:
setClass("RangedNumeric",
  contains = "numeric",
  slots = list(min = "numeric", max = "numeric"))
rn <- new("RangedNumeric",  min = 1, max = 10,1:10)
rn@min
rn@.Data

###Create or set function to be generic
#if there is function already
setGeneric("union")
setMethod("union",c(x="data.frame",y="data.frame"),function(x,y){unique(rbind(x,y))}) 
#generic name, classes the method shall be associated with, a func implements the method

#if create generic from scratch:
setGeneric("myGeneric", function(x) {
  standardGeneric("myGeneric")
})

###Method dispatch
selectMethod("nobs",list("mle"))  
#similar to getMethod(genericname,signature)
method_from_call(nobs(fit))


###Initialize Method
track <- setClass("track",
         slots = c(x="numeric", y="numeric"))
trackCurve <- setClass("trackCurve",
    slots = c(smooth = "numeric"),
    contains = "track")

setMethod("initialize",
          "track",
          function(.Object, x = numeric(0), y = numeric(0)) {
            if(nargs() > 1) {
              if(length(x) != length(y))
                stop("specified x and y of different lengths")
              .Object@x <- x
              .Object@y <- y
            }
            .Object
          })
#above initialize func will apply to both track and trackCurve so:
t1 <- track(x = 1:10, y = 1:10 + rnorm(10))
t2 <- new("trackCurve", t1, smooth = 22) #WOULD NOT WORK!!

#Better init in this way
setMethod("initialize", "track", function(.Object, ...) {
    .Object <- callNextMethod()
    if(length(.Object@x) != length(.Object@y))
     stop("specified x and y of different lengths")
    .Object
  })
t1 <- track(x = 1:10, y = 1:10 + rnorm(10))
t2 <- new("trackCurve", t1, smooth = 22) #WORKED


###callNextMethod###
#call parents` methods until to generic function
setClass("B0" , representation(b0 = "numeric"))

setClass("B1", representation(b1 = "character"), contains = "B0")

setClass("B2", representation(b2 = "logical"), contains = "B1")

## and a rather silly function to illustrate callNextMethod
f <- function(x) class(x)
setMethod("f", "B0", function(x) c(x@b0^2, callNextMethod()))
setMethod("f", "B1", function(x) c(paste(x@b1,":"), callNextMethod()))
setMethod("f", "B2", function(x) c(x@b2, callNextMethod()))
b1 <- new("B1", b0 = 2, b1 = "Testing")
b2 <- new("B2", b2 = FALSE, b1 = "More testing", b0 = 10)
f(b1)
#Here f function has methods for "ANY","B0"...,
#callNextMethod would call f.B1->f.B0->f.ANY

###replacement function# change the value without copy
setClass("foo", representation(a = "ANY"))
setGeneric("a",  function(object) standardGeneric("a"))
setMethod("a", "foo", function(object) object@a)
b <- new("foo", a = 10)
a(b)
#a(b)=12: Error couldnt find function a<-

#lets build generic replace func
setGeneric("a<-", function(x, value) standardGeneric("a<-"))
setReplaceMethod("a", "foo", function(x, value) {
  x@a<-value
  x
})
a(b)=32
#however, this b has different address now

###Exercise1 Which S4 generic has the most methods defined for it? Which S4 class has the most methods associated with it?
s4genericglobal=Filter(function(f){if(exists(f)){isS4(get(f))}else F},getGenerics()@.Data) #filter out s4 generics
count=sapply(
  s4genericglobal,
  function(x){ length(findMethods(x)@signatures)})
which(count==max(count)) #coerce 8

s4classesglobal=Filter(function(f){isS4(getClass(f,where=search()))},getClasses(where=search()))
count=sapply(
  s4classesglobal,
  function(x){ length(showMethods(class=x,printTo=F)[ grep("Function",showMethods(class="RangedNumeric", printTo =FALSE ))])})
which(count==max(count)) 

###Exercise2 What happens if you define a new S4 class that doesnâ€™t â€œcontainâ€? an existing class? (Hint: read about virtual classes in ?Classes.)
setClass("Person") OR #setClass("Person",slots...,contains="VIRTUAL")
#cannot use new() to create objects but could be extended by subclass

###Exercise3 What happens if you pass an S4 object to an S3 generic? What happens if you pass an S3 object to an S4 generic? (Hint: read ?setOldClass for the second case.)
#s3 class
stamped <- function(x, date = Sys.time()) {
    if(!inherits(date, "POSIXt"))
      stop("bad date argument")
    if(!is.vector(x))
      stop("x must be a vector")
    attr(x, "date") <- date
    class(x) <- "stamped"
    x
}

print.stamped <- function(x, ...) {
    print(as.vector(x))
    cat("Date: ",  format(attr(x,"date")), "s3print\n")
}
test=function(x,...){
  UseMethod("test")
}
# test.vector=function(x){
#   print("This is test.vector function for stamped s3 class")
# }
test.stamped=function(x){
  print("This is the test.stamped function for stamped s3 class")
}
x=stamped("xxx")

##Pass s4 to s3 generic (), but s4 must be a class converted from s3 by setOldClass(s3,S4Class=s4)

setClass("stamped4", contains = "vector", representation(date = "POSIXt"))
#This is the important part, stamped4 extends vector, then setOldClass make stamped extends stamped4
#so when test function is called on s3 obj of stamped, it searches for 
# setGeneric("test",function(object) {
#   standardGeneric("test")
# })

#setOldClass("stamped", S4Class = "stamped4") #convert stamped to stamped4 that extends vector
#And add oldclass to extends as well.
#selectMethod("show", "stamped") #
#selectMethod("test","stamped") #This will report an error, because s4 generic test havent been defined
#But, you cannot setGeneric("test",...) cuz it will override s3 test function
#What u could do is: setMethod("test","stamped4",function....) and then selectMethod, this will link #s4method to s3 method 
#or just don`t add this command, and u would directly invoke s3 test
removeClass("stamped4")
someLetters <- stamped(sample(letters, 10),
                       ISOdatetime(2008, 10, 15, 12, 0, 0))
st <- new("stamped", someLetters)
test(x) #s3 generic call s4 class

##S4 generic call s3 obj
x=stamped("xxx")
setGeneric("test",function(object) {
  standardGeneric("test")
})
setMethod("test","stamped4",function(object){print("This is test function for stamped4 s4 class")})
#test(x) #Because test generic has been overriden, it returns an error
setOldClass(c("stamped","stamped4"),S4Class="stamped4") 
#connect stamped with S3Class(stamped4) and then stamped, S3Class(stamped4) extends stamped4
#

selectMethod("test", "stamped")
test(x) #now stamped is also a s4 class
#setOldClass("stamped", S4Class = "stamped4") #this along dont extend stamped4 but oldclas
###Good Example of S4 OOP: Model bank and cashpoints: Basetra/programming/prediction.R


###################
##Reference class##
###################
###Exercise1
Account <- setRefClass("Account",
  fields = list(.balance = "numeric"),
  methods = list(
    withdraw = function(x) {
      temp=.balance-x
      print(temp)
      return(Account$new(.balance=temp)) 
    },
    deposit = function(x) {
      .balance <<- .balance + x
    },
    getBalance=function(){
      return(.balance)
    }
    
  )
)
Account$lock(".balance")
a=Account$new(.balance=100)

NoOverdraft <- setRefClass("NoOverdraft",
  contains = "Account",
  methods = list(
    withdraw = function(x) {
      if (.balance < x) stop("Not enough money")
      .balance <<- .balance - x
    }
  )
)
accountJohn <- NoOverdraft$new(.balance = 100)


```

Chapter 8 Environments
```{r chapter 8 environments}
#Exercise2 Write your own version of get() using a function written in the style of where().
get=function(name,env=parent.frame()){
  stopifnot(class(name)=="character")
  while(!identical(env,emptyenv())){
    #print(env)
    if(exists(name,env,inherits = FALSE)){return(env[[name]])}
    env=parent.env(env)
  }
}
e=new.env(parent=parent.frame())
e$name="This is for test get func"
attach(e) #IMPORTANT STEP, otherwise, look up procedure will not find "e"
##Or new.env(parent = emptyenv())
get("name")
parent.env(.GlobalEnv) #e


###four environments: enclosing env, binding env, execution env, calling env
#Exercise5 Write an enhanced version of str() that provides more information about functions. Show where the function was found and what environment it was defined in.
f1 <- function(x1) {
  f2 <- function(x2) {
    f3 <- function(x3) {
      x1 + x2 + x3
    }
    f3(3)
  }
  f2(2)
  
}
plus <- function(x) {
  function(y) x + y
}
plus_one <- plus(1)
identical(parent.env(environment(plus_one)), environment(plus))


pryrfunccall=function (f) 
{
    if (is.function(f)) {
        fun_calls(body(f))
    }
    else if (is.call(f)) {
        fname <- as.character(f[[1]])
        if (identical(fname, ".Internal")) 
            return(fname)
        unique(c(fname, unlist(lapply(f[-1], fun_calls), use.names = FALSE)))
    }
}

#####IMPORTANT!!!!! HOW TO CONVERT ENVIRONMENT TO STRING:
e=new.env()
#cat(e)#error
format(e) #character
####MANY OBJECT IS ACTUALLY FORMATED BEFORE INVOKING PRINT FUNCTION

?sys.frame
attach(e)
e$f2=f1
str.function=function(f){
  require(pryr)
  cat("Found in(enclosing env): ",format(environment(f)),"\n");
  cat("Defined in: ", format(where(as.character(substitute(f))))," Named: ",attr(where(as.character(substitute(f))),"name"))
  #str(f)
}

######################
##Bindings to values##
######################
###Delayed bindings
library(pryr)
system.time(b %<d-% {Sys.sleep(1); 1}) #delayed binding
system.time(b)

##Active bindings
x %<a-% runif(1)
x
x #different

###Rebind #bind value to name if name exists else search upwards
rebind <- function(name, value, env = parent.frame()) {
  if (identical(env, emptyenv())) {
    stop("Can't find ", name, call. = FALSE)
  } else if (exists(name, envir = env, inherits = FALSE)) {
    assign(name, value, envir = env)
  } else {
    rebind(name, value, parent.env(env))
  }
}

#compared with <<-, it rebinds name with variables of current calling environments,not parent.env

myassign<-function(name,value){
  require(pryr)
  flag=format(tryCatch({where(name)},error=function(e){return("Error")}))
  stopifnot(flag=="Error")
  assign(name,value)
}#if old name, assign break


##?? Exercise3: Write an assignment function that can do active, delayed, and locked bindings. What might you call it? What arguments should it take? Can you guess which sort of assignment it should do based on the input? 


###############################
##reference semantics of env###
###############################
modify <- function(x) {
  x$a <- 2
  invisible()
}
x <- 1
e1 <- new.env()
get("x", envir = e1)

e2 <- new.env(parent = emptyenv())
get("x", envir = e2) #error

# Environments are data structures useful for solving three common problems:
# 
# Avoiding copies of large data. #But Changes to R 3.1.0 have made this use substantially less important because modifying a list no longer makes a deep copy.
# Managing state within a package.
# Efficiently looking up values from names.
```

Debugging, condition handling, and defensive programming
```{r Debug}
##bug code
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) "a" + d
f(10)


browseOnce <- function() {
  old <- getOption("error")
  function() {
    options(error = old) #set options(error to null)
    browser() #but still execute browser() once
  }
}
options(error = browseOnce())

f <- function() stop("!")
# Enters browser
f()
# Runs normally
f()


###Convert warnings to errors
 options(warn = 2)
 
success <- try(1 + 2)
failure <- try("a" + "b")
class(success)
#> [1] "numeric"
class(failure)
#> [1] "try-error"

###tryCatch implement try
try2 <- function(code, silent = FALSE) {
  tryCatch(code, error = function(c) {
    msg <- conditionMessage(c)
    if (!silent) message(c)
    invisible(structure(msg, class = "try-error")) #IMPORTANT~~ create a string with class
  })
}

##interrupt
i <- 1
while(i < 3) {
  tryCatch({
    Sys.sleep(0.5)
    message("Try to escape")
  }, interrupt = function(x) {
    message("Try again!")
    i <<- i + 1
  })
}

###sys.calls() :runtime traceback()
f <- function() g()
g <- function() h()
h <- function() stop("!")
tryCatch(f(), error = function(e) print(sys.calls()))


####Distinguish different types of error####
# Conditions must contain message and call components, and may contain other useful components. When creating a new condition, it should always inherit from condition and one of error, warning, or message.

condition <- function(subclass, message, call = sys.call(-1), ...) {
  structure(
    class = c(subclass, "condition"),
    list(message = message, call = call),
    ...
  )
}
is.condition <- function(x) inherits(x, "condition")
c <- condition(c("my_error", "error"), "This is an error")


custom_stop <- function(subclass, message, call = sys.call(-1), 
                        ...) {
  c <- condition(c(subclass, "error"), message, call = call, ...)
  stop(c)
}

my_log <- function(x) {
  if (!is.numeric(x))
    custom_stop("invalid_class", "my_log() needs numeric input")
  if (any(x < 0))
    custom_stop("invalid_value", "my_log() needs positive inputs")

  log(x)
}

##Or
my_log <- function(x) {
  if (!is.numeric(x))
    c <- condition(c("invalid_class","error"), "my_log() needs numeric input")
    signalCondition(c) #This is important step to let tryCatch really catch the signal
  if (any(x < 0))
    c <- condition(c("invalid_value","error"), "my_log() needs positive input")
    signalCondition(c) #This is important step to let tryCatch really catch the signal

  log(x)
}

tryCatch(
  my_log("a"),
  invalid_class = function(c) "class",
  invalid_value = function(c) "value"
)
#this will first trigger the if stat in my_log, invoke custom_stop invalid_class and generate c condition

###Exercise: Difference between withCallingHandlers and tryCatch
message2error <- function(code) {
  withCallingHandlers(code, message = function(e) stop(e))
}
message2error("a"+1)
traceback() #Trace stoped at withCallingHandlers (it don`t return anything)
message2error <- function(code) {
  tryCatch(code, message = function(e) stop(e))
}
message2error("a"+1)
traceback() #traced back to steps in tryCatch

################################
###Defensive programming########
################################
## "Fail fast"
## Non-standard evaluation like subset, transform, and with often fail with uninformative error messages
## if your function is not vectorised in its inputs, but uses functions that are, make sure to check that the inputs are scalars. 
## Avoid functions that return different types of output depending on their input. 
##  never use sapply() inside a function: always use the stricter vapply() which will throw an error if the inputs are incorrect types and return the correct type of output even for zero-length inputs.
# vapply returns a vector or array of type matching the FUN.VALUE.


###Exercise : 
col_means <- function(df) {
  numeric <- sapply(df, is.numeric)
  numeric_cols <- df[, numeric]

  data.frame(lapply(numeric_cols, mean))
}

```

Functional Programming
```{r functional programming}
######################
##list of functnion###
######################
compute_mean <- list(
  base = function(x) mean(x),
  sum = function(x) sum(x) / length(x),
  manual = function(x) {
    total <- 0
    n <- length(x)
    for (i in seq_along(x)) {
      total <- total + x[i] / n
    }
    total
  }
)
lapply(compute_mean, function(f) f(x))
#> $base
#> [1] 0.4994771
#> 
#> $sum
#> [1] 0.4994771
#> 
#> $manual
#> [1] 0.4994771

call_fun <- function(f, ...) f(...)

lapply(compute_mean, call_fun, x)
#> $base
#> [1] 0.4994771
#> 
#> $sum
#> [1] 0.4994771
#> 
#> $manual
#> [1] 0.4994771
lapply(compute_mean, function(f) system.time(f(x)))

lapply(compute_mean, function(f) f(x, na.rm = TRUE))

######################################################
##Moving lists of functions to the global environment#
######################################################
simple_tag <- function(tag) {
  force(tag)
  function(...) {
    paste0("<", tag, ">", paste0(...), "</", tag, ">")
  }
}
tags <- c("p", "b", "i")
html <- lapply(setNames(tags, tags), simple_tag)
# keeping them in a list makes code more verbose:
html$p("This is ", html$b("bold"), " text.")

####three options to eliminate the use of html$:
#1.(recommended) for very temporary effect use with():
with(html, p("This is ", b("bold"), " text."))

#2. for longer effect use attach(), detach():
attach(html)
p("This is ", b("bold"), " text.")
#> [1] "<p>This is <b>bold</b> text.</p>"
detach(html)

#3. list2env
list2env(html, environment())
#> <environment: R_GlobalEnv>
p("This is ", b("bold"), " text.")
#> [1] "<p>This is <b>bold</b> text.</p>"
rm(list = names(html), envir = environment())

##Exercise1. 
mysummary=function(otype){
  funclist=as.list(methods("summary"))
  names(funclist)=gsub("summary.","",as.character(methods("summary")))
  if(otype %in% names(funclist)){
    function(x){
      get(funclist[[otype]])(x)
    }
  }
}

#2.Which of the following commands is equivalent to with(x, f(z))?
# x$f(x$z).
# f(x$z).
# x$f(z).
# f(z).
#A: It depends. f in the list x first look for z in x, if not found , look up to global 
x=list(f=function(x){print(x)},z="haha")
as.environment(x) #list could be a different env from global

################
###Case Study###
################
midpoint <- function(f, a, b) {
  (b - a) * f((a + b) / 2) #çŸ©å½¢é¢ç§¯
}

trapezoid <- function(f, a, b) {
  (b - a) / 2 * (f(a) + f(b)) #æ¢¯å½¢é¢ç§¯
}

midpoint(sin, 0, pi)
#> [1] 3.141593
trapezoid(sin, 0, pi)
#> [1] 1.923671e-16

###Above shows the approximation of area is not accurate enough
###So lets break up the range into smaller pieces
### composite integration. Iâ€™ll implement it using two new functions:

midpoint_composite <- function(f, a, b, n = 10) {
  points <- seq(a, b, length = n + 1)
  h <- (b - a) / n

  area <- 0
  for (i in seq_len(n)) {
    area <- area + h * f((points[i] + points[i + 1]) / 2)
  }
  area
}

trapezoid_composite <- function(f, a, b, n = 10) {
  points <- seq(a, b, length = n + 1)
  h <- (b - a) / n

  area <- 0
  for (i in seq_len(n)) {
    area <- area + h / 2 * (f(points[i]) + f(points[i + 1]))
  }
  area
}

midpoint_composite(sin, 0, pi, n = 10)
#> [1] 2.008248
midpoint_composite(sin, 0, pi, n = 100)
#> [1] 2.000082
trapezoid_composite(sin, 0, pi, n = 10)
#> [1] 1.983524
trapezoid_composite(sin, 0, pi, n = 100)

####Now we see both functions are quite duplicated in code
#the difference actually lie in the for loop where it calculates the area according to specific rule
composite <- function(f, a, b, n = 10, rule) {
  points <- seq(a, b, length = n + 1)

  area <- 0
  for (i in seq_len(n)) {
    area <- area + rule(f, points[i], points[i + 1])
    #Here rule is either function midpoint or trapezoid defined early at start.
  }

  area
}

###Since rules could be replaced, the integration allows trying different rules
simpson <- function(f, a, b) {
  (b - a) / 6 * (f(a) + 4 * f((a + b) / 2) + f(b))
  ##(2*midpoint-rectangle+trapezoid)/3
}

boole <- function(f, a, b) {
  pos <- function(i) a + i * (b - a) / 4
  fi <- function(i) f(pos(i))

  (b - a) / 90 *
    (7 * fi(0) + 32 * fi(1) + 12 * fi(2) + 32 * fi(3) + 7 * fi(4))
}


###these rules are all childs of newton-cotes rules
newton_cotes <- function(coef, open = FALSE) {
  n <- length(coef) + open

  function(f, a, b) {
    pos <- function(i) a + i * (b - a) / n
    points <- pos(seq.int(0, length(coef) - 1))

    (b - a) / sum(coef) * sum(f(points) * coef)
  }
}

boole <- newton_cotes(c(7, 32, 12, 32, 7))
milne <- newton_cotes(c(2, -1, 2), open = TRUE)
composite(sin, 0, pi, n = 10, rule = milne)

rules=list(boole,milne,midpoint,trapezoid,simpson)
#Exercise 2: The trade-off between integration rules is that more complex rules are slower to compute, but need fewer pieces. For sin() in the range [0, Ï€], determine the number of pieces needed so that each rule will be equally accurate. Illustrate your results with a graph. How do they change for different functions? sin(1 / x^2) is particularly challenging.

##PAY ATTENTION TO = , <- and -> they are different!!:
snm=c("asdf","dsf","")
any(nonames=sm=="");nonames;  # TRUE ; object 'nonames' not found
any(nonames->sm=="");nonames; # object 'nonames' not found
any(nonames<-snm=="");nonames;# TRUE ; FALSE FALSE  TRUE
#-> is typically used as: value -> x
#The operators <- and = assign into the environment in which they are evaluated
#The operator <- can be used anywhere, whereas the operator = is only allowed at the top level, which means it is not allowed in control structures like if
#use = will apply precedence i.e.: x <- y = 5#Error (x<-y) =5, it`s actually `=`(`<-`(x, y), 5)
median(x = 1:10)
x   
## Error: object 'x' not found
#x is declared within the scope of the function, so it does not exist in the user workspace
###SUMMARY: x<-value can live out side of judge sentences while x=value cannot!!!

###Greatly written##
namedlist=function(...){
  result=list(...)
  #sapply(substitute(list(a="ff",1)),deparse) this step convert all vector with assigned name
  #so all we have to do is find out which one doesnt have a name and assign it.
  lnames=sapply(substitute(list(...)),deparse)[-1] #remove "list" in the vector
  if(is.null(nm<-names(result))) nm<-lnames
  if (any(nonames <- nm=="")) nm[nonames] <- lnames[nonames]
  setNames(result,nm)
}
rules=namedlist(milne,boole,midpoint,trapezoid)
plotnVSarea=function(func,n,rules){
  require(reshape2)
  require(ggplot2)
  df=list()
  for (rule in names(rules)){
    df[[rule]]=sapply(seq_len(n),function(x) composite(func, 0, pi, n = x,rule=rules[[rule]]))
  }
  df$npieces=seq_len(n)
  df=as.data.frame(df)
  plot(x=seq_len(n))
  npieces=which.min(apply(df[,-dim(df)[2]],1,sd))
  df=melt(df,id="npieces")
  ggplot(df,aes(x=npieces,y=value,fill=variable,color=variable))+geom_point(pch=19)+theme_bw()
  cat("The number of pieces is: ",npieces, "to make rule sd minimized\n")
  return(npieces)
}
```
Functionals

```{r Funtionals}
#i.e.: lapply, apply
# The complement to a closure is a functional, a function that takes a function as an input and returns a vector as output
randomise <- function(f) f(runif(1e3))
randomise(mean)
#> [1] 0.5096054
randomise(mean)
#> [1] 0.5123963
randomise(sum)
#> [1] 491.1766

###Common use of functionals: 
#1 replace for loop to improve expressiveness
#2 using functionals will not always produce the fastest code. Instead, it helps you clearly communicate and build tools that solve a wide range of problems.

##################
##Sth about Loop##
##################
#1.loop over the elements: for (x in xs)
#2.loop over the numeric indices: for (i in seq_along(xs))
#3.loop over the names: for (nm in names(xs))

#first is slow: output is usually extending the vector: res<-c(res,x)
#second is better by: create the space at begining: res<-numeric(length(??)),then loop through vector



##################################
#Vector output: sapply and vapply#
##################################
#vapply() is more verbose, but gives more informative error messages and never fails silently. It is better suited for use inside other functions
vapply(list(), is.numeric, logical(1))
#> logical(0)

#####################################
###Multiple Inputs: Map and mapply###
#####################################
# Generate some sample data
xs <- replicate(5, runif(10), simplify = FALSE)
ws <- replicate(5, rpois(10, 5) + 1, simplify = FALSE)
#unweighted means:
unlist(lapply(xs, mean))

#while weighted means are calculated as: weighted.mean(xs[[i]], ws[[i]])
#so lapply should loop the seq_along(xs)
unlist(lapply(seq_along(xs), function(i) {
  weighted.mean(xs[[i]], ws[[i]])
}))

#Worked But clumsy, Map is better as a variant of lapply
unlist(Map(weighted.mean,xs,ws))
#NOTE: lapply(data,func), Map(func,data1,data2...)
#Map is equivalent to 
stopifnot(length(xs) == length(ws))
out <- vector("list", length(xs))
for (i in seq_along(xs)) {
  out[[i]] <- weighted.mean(xs[[i]], ws[[i]])
}

##it could also divide complicated lapply function to two steps to ease debuging
mtmeans <- lapply(mtcars, mean)
mtmeans[] <- Map(`/`, mtcars, mtmeans)

# In this case, equivalent to
mtcars[] <- lapply(mtcars, function(x) x / mean(x))
#If some of the arguments should be fixed and constant, use an anonymous function:

Map(function(x, w) weighted.mean(x, w, na.rm = TRUE), xs, ws)

####Mapply
#Map is equivalent to mapply with simplify=F, and is more recommended
#mapply has the MoreArgs argument that takes a list of extra arguments that will be supplied, as is, to each call. This breaks Râ€™s usual lazy evaluation semantics, and is inconsistent with other functions.

#############################
##Rolling computations######
#############################
#rollmean to smooth
#n is the number of points it`s gonna come across to compute mean
rollmean <- function(x, n) {
  out <- rep(NA, length(x))

  offset <- trunc(n / 2)
  for (i in (offset + 1):(length(x) - n + offset + 1)) {
    out[i] <- mean(x[(i - offset):(i + offset - 1)])
  }
  out
}
x <- seq(1, 3, length = 10) + runif(10)
plot(x)
lines(rollmean(x, 5), col = "blue", lwd = 2)
###Note! use debug(rollmean);rollmean(x,5) to see value changes
lines(rollmean(x, 10), col = "red", lwd = 2)

##rewrite rollmean
rollapply <- function(x, n, f, ...) {
  out <- rep(NA, length(x))

  offset <- trunc(n / 2)
  for (i in (offset + 1):(length(x) - n + offset + 1)) {
    out[i] <- f(x[(i - offset):(i + offset)], ...)
  }
  out
}
plot(x)
lines(rollapply(x, 5, median), col = "red", lwd = 2)

#rewrite again! effectively the same as the implementation in zoo::rollapply()
rollapply <- function(x, n, f, ...) {
  offset <- trunc(n / 2)
  locs <- (offset + 1):(length(x) - n + offset + 1)
  num <- vapply(
    locs, 
    function(i) f(x[(i - offset):(i + offset)], ...),
    numeric(1)
  )

  c(rep(NA, offset), num)
}

######################
##Parallelisation#####
######################
#lapply is order independent:
lapply3 <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in sample(seq_along(x))) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
unlist(lapply(1:10, sqrt))
#>  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751
#>  [8] 2.828427 3.000000 3.162278
unlist(lapply3(1:10, sqrt))
#>  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751
#>  [8] 2.828427 3.000000 3.162278

##That makes parallelization possible
##This is what parallel::mclapply() (and parallel::mcMap()) does. (These functions are not available in Windows, but you can use the similar parLapply() with a bit more work. See parallelise for more details.)

###Exercise2: Why is using sapply() to get the class() of each element in a data frame dangerous?
#It wont warn you if class attr has length >2

###Exercise3:
#repeat runing a function for 100times!
trials <- replicate(
  100, 
  t.test(rpois(10, 10), rpois(7, 10)),
  simplify = FALSE
)
test=sapply(trials, `[[`,"p.value")
  
###Exercise5:Implement a version of lapply() that supplies FUN with both the name and the value of each component.
bapply=function(inputlist,f,...){
  if(is.null(names(inputlist))) stop("No names in the list")
  for (i in seq_along(inputlist)){
    f(i,...)
    f(names(inputlist)[i],...)
  }
}

###???Exercise6: Implement a combination of Map() and vapply() to create an lapply() variant that iterates in parallel over all of its inputs and stores its outputs in a vector (or a matrix). What arguments should the function take?

###???Exercise7:Implement mcsapply(), a multicore version of sapply(). Can you implement mcvapply(), a parallel version of vapply()? Why or why not?


#####################################
###Functionals for matrices or dfs###
#####################################
aperm() #put high-dim array  back in right order
sweep() #apply to a matrix by row or col, and func with same length vector iteratively
    x <- matrix(rnorm(20, 0, 10), nrow = 4)
    x1 <- sweep(x, 1, apply(x, 1, min), `-`) #
    x2 <- sweep(x1, 1, apply(x1, 1, max), `/`)
outer(1:3,1:10,"*")
#outer(è¡?, åˆ?,"*"), è¡Œå…ƒç´?1ä¸Žæ‰€æœ‰åˆ—è¿›è¡Œ"*" ç„¶åŽè¡?2....

rapply() #recursively apply function to list elements
myFun <- function(x){
    if (is.character(x)){
    return(paste(x,"!",sep=""))
    }
    else{
    return(x + 1)
    }
}

#A nested list structure
l <- list(a = list(a1 = "Boo", b1 = 2, c1 = "Eeek"), 
          b = 3, c = "Yikes", 
          d = list(a2 = 1, b2 = list(a3 = "Hey", b3 = 5)))
#Result is named vector, coerced to character           
rapply(l,myFun)
#Result is a nested list like l, with values altered
rapply(l, myFun, how = "replace")

#################
###Group apply###
#################
tapply(x,INDEX,FUN,simplify)  
##apply that allows "ragged" arrays where each row could have different num of cols
##kinda like aggregate which is actually tapply at cores

pulse <- round(rnorm(22, 70, 10 / 3)) + rep(c(0, 5), c(10, 12))
group <- rep(c("A", "B"), c(10, 12))
tapply(pulse, group, length)
#machanism:
data=split(pulse, group)
sapply(data, length)


by() ##usually used when tapply is not able to handle
######Compare tapply and by###############
#similarity between tapply and by:
ct <- tapply(iris$Sepal.Width , iris$Species , summary )
cb <- by(iris$Sepal.Width , iris$Species , summary )
#difference:
tapply(iris, iris$Species, summary ) #Error arguments must have same length
#Here tapply cant apply to data frame, dim(iris) and iris$Species are different
by(iris, iris$Species, summary ) #worked like a charm
#Worked by subset dataframe by iris$Species and apply function to sub-dataframe

######Compare tapply and aggregate#########
#second argument of aggregate must be a list while tapply can (not mandatory) be a list and that the output of aggregate is a data frame while the one of tapply is an array.

#######Compare by and aggregate##########
#
ag1 <- aggregate(cbind(Ozone, Temp) ~ Month, data = airquality, mean)
by(airquality[c("Ozone", "Temp")], airquality$Month, mean, na.rm = TRUE) ##Error cuz mean func doesnt apply to function

###Summary in input output###
# Base function   Input   Output   plyr function 
# ---------------------------------------
# aggregate        d       d       ddply + colwise 
# apply            a       a/l     aaply / alply 
# by               d       l       dlply 
# lapply           l       l       llply  
# mapply           a       a/l     maply / mlply 
# replicate        r       a/l     raply / rlply 
# sapply           l       a       laply 


##################
####plyr package##
##################
#to make base functionals consistent

###Exercise2: Thereâ€™s no equivalent to split() + vapply(). Should there be? When would it be useful? Implement one yourself.
pulse <- round(rnorm(22, 70, 10 / 3)) + rep(c(0, 5), c(10, 12))
group <- rep(c("A", "B"), c(10, 12))
data=split(pulse, group)
sapply(data, length) #worked even data is ragged
vapply(data,as.character,FUN.VALUE = character(10)) #not worked,FUN[[2]] is 12 length
vapply(data, is.numeric,FUN.VALUE = logical(1)) # worked cuz fun return a logical result each loop
vapply(data, is.numeric,FUN.VALUE = numeric(1)) #worked cuz logical<numeric<double<complex
vapply(data,is.numeric,character(1))
#not worked, cuz coercion to character is not in vapply coercion table 
vapply(data, function(x){if(is.numeric(x)) as.character(is.numeric(x))},FUN.VALUE = character(1)) 
#wored, cuz func coerced result to character that matches FUN.VALUE
data$A=c(data$A,c(1,2))
vapply(data,as.character,FUN.VALUE = character(12)) #worked cuz each loop result length is 12
#Summary: vapply applies only to unragged data and is not suitable for character results when coercion is needed for results generated from func

###Exercise3: Implement a pure R version of split(). (Hint: use unique() and subsetting.) Can you do it without a for loop?
split(pulse, group) #split vector

df=data.frame(p=pulse,g=group)
split(df,group) #split dataframe

mysplit=function(data,group){
  if(is.data.frame(data)==FALSE) tapply(data,group,`[`)
  else by(data,group,`[`)
}
##??how not to use for loop???

#DHDC08P1_0304:1:2108:11503:92934#AGTCAACA


########################
##Manipulating list#####
########################
#Reduce :also known as combine step, fold step.
l <- replicate(5, sample(1:10, 15, replace = T), simplify = FALSE) #simplify =FALSE to generate list
intersect(intersect(intersect(intersect(l[[1]], l[[2]]),
  l[[3]]), l[[4]]), l[[5]])
Reduce(intersect, l)
#compute first two args, then result with third, then result with fourth


############################
###Predicated functionals###
############################
# Filter() only return elements match the predicate,wont return data frame with specific col match predicate
# Find() return first element match or last element with right =TRUE
# Position() return pos as above

###Exercise1: Why isnâ€™t is.na() a predicate function? What base R function is closest to being a predicate version of is.na()?
#is.na is not a predicate cuz predicate returns a single T or F, is.na could return a vector of T,F
#anyNA

###Exercise2: Use Filter() and vapply() to create a function that applies a summary statistic to every numeric column in a data frame.
df <- data.frame(x = 1:3, y = c("a", "b", "c"),z=2:4)
mysummary=function(df){
  summary(Filter(is.numeric,df))
}

###Exercise4:Implement Any(), a function that takes a list and a predicate function, and returns TRUE if the predicate function returns TRUE for any of the inputs. Implement All() similarly.
myany=function(inputlist,f){
  TRUE %in% lapply(inputlist,f)
}
myall=function(inputlist,f){
  !(FALSE %in% lapply(inputlist,f))
}

###???Exercise5:Implement the span() function from Haskell: given a list x and a predicate function f, span returns the location of the longest sequential run of elements where the predicate is true. (Hint: you might find rle() helpful.)

##############################
###mathematical functionals###
##############################
# integrate() finds the area under the curve defined by f()
# uniroot() finds "first" where f() hits zero
# optimise() finds the location of lowest (or highest) value of f()

uniroot(sin, c(2,2*pi)) #find first x where sin(x) is 0
optimise(sin, c(0, 2 * pi),maximum = T) #find x where sin(x) is max

#optimise is widely used for computing ML of things
#First, we create a function factory that, given a dataset, returns a function that computes the negative log likelihood (NLL) for parameter lambda. In R, itâ€™s common to work with the negative since optimise() defaults to finding the minimum.

poisson_nll <- function(x) {
  n <- length(x)
  sum_x <- sum(x)
  function(lambda) {
    n * lambda - sum_x * log(lambda) # + terms not involving lambda
  }
}
x1 <- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)
x2 <- c(6, 4, 7, 3, 3, 7, 5, 2, 2, 7, 5, 4, 12, 6, 9)
nll1 <- poisson_nll(x1)
nll2 <- poisson_nll(x2)

optimise(nll1, c(0, 100))$minimum
#> [1] 32.09999
optimise(nll2, c(0, 100))$minimum
#> [1] 5.466681

###optim(): a generalisation of optimise() that works with more than one dimension

###Exercies1: Implement arg_max(). It should take a function and a vector of inputs, and return the elements of the input where the function returns the highest value. For example, arg_max(-10:5, function(x) x ^ 2) should return -10. arg_max(-5:5, function(x) x ^ 2) should return c(-5, 5). Also implement the matching arg_min() function.
arg_max=function(x,f){
  res=f(x)
  x[which(res==max(res))]
}

###Exercise2: Challenge: read about the fixed point algorithm. Complete the exercises using R.
#fixed point: A number x is called a fixed point of a function f if x satisfies the equation f(x) = x
fixedPoints=function(f,...){
  fclosure=function(lambda){
      abs(f(lambda)-lambda) #lambda is the guess
  }
  optimise(fclosure,...)$minimum
}

#similarly: square root function could be explained as: find minimal x where sqrt(x)=~x
mysquaureroot=function(x){
  fclosure=function(lambda){
    abs(x/lambda-lambda) #lambda is the guess
  }
  optimise(fclosure,c(0,x))$minimum
}

#####################################
####Loops that better left as is#####
#####################################
#1. Modifying in place
#If you need to modify part of an existing data frame, itâ€™s often better to use a for loop. 
#2. Recursive relationships
#Itâ€™s hard to convert a for loop into a functional when the relationship between elements is not independent, or is defined recursively.

#eliminate while loop
i <- 0
while(TRUE) {
  if (runif(1) > 0.9) break
  i <- i + 1
}
#can turn into:
i <- rgeom(1, 0.1)
#the while simply mean the success in each trial is 0<prob<0.1

#################
###Case study####
#################
# take a simple building block and make it powerful and general.
# Project : add function
# This function take two args and return values that are not NA
rm_na <- function(x, y, identity) {
  if (is.na(x) && is.na(y)) {
    identity
  } else if (is.na(x)) {
    y
  } else {
    x
  }
}  
### It is combined with add to dealwith NA inputs  
add <- function(x, y, na.rm = FALSE) {
  if (na.rm && (is.na(x) || is.na(y))) rm_na(x, y, 0) else x + y
}

###lets extend add to multiple inputs
r_add <- function(xs, na.rm = TRUE) {
  Reduce(function(x, y) add(x, y, na.rm = na.rm), xs)
}
r_add(c(1, 4, 10))
#> [1] 15
#Note the r_add didn`t test case that xs is just length 1 or 0
r_add(NA, na.rm = TRUE)
#> [1] NA
r_add(numeric())
#> NULL
r_add(1)  #in this con,xs is only length 1 and it still worked .We can tell it`s because of 
#Reduce(),  If we give Reduce() a length one vector, it doesnâ€™t have anything to reduce, so it just returns the input. If we give it an input of length zero, it always returns NULL. 

###simply add init arg
r_add <- function(xs, na.rm = TRUE) {
  Reduce(function(x, y) add(x, y, na.rm = na.rm), xs, init = 0)
}
r_add(c(1, 4, 10))
#> [1] 15
r_add(NA, na.rm = TRUE)
#> [1] 0
r_add(numeric())
#> [1] 0

###Note add is not vectorised, lets make it to be so
#vectorise by Map or vapply
v_add1=function(x,y,na.rm=F){
  stopifnot(length(x)==length(y),is.numeric(x),is.numeric(y)) #pay attention to the grammer
  if(length(x)==0 ||length(y)==0) return(numeric())
  simplify2array(
    Map(add(na.rm=na.rm),x,y)
  )
}

v_add2=function(x,y,na.rm=F){
  stopifnot(length(x)==length(y),is.numeric(x),is.numeric(y)) #pay attention to the grammer
  vapply(seq_along(x),function(i){add(x[i],y[i],na.rm=na.rm)},numeric(1))
}

###variant of add: Cumulative sum
c_add <- function(xs, na.rm = FALSE) {
  Reduce(function(x, y) add(x, y, na.rm = na.rm), xs,
    accumulate = TRUE)
}
#by setting accumulate=T, it print out result of every combine
#This is equivalent to cumsum().

###Exercise1: Implement smaller and larger functions that, given two inputs, return either the smaller or the larger value. Implement na.rm = TRUE: what should the identity be? (Hint: smaller(x, smaller(NA, NA, na.rm = TRUE), na.rm = TRUE) must be x, so smaller(NA, NA, na.rm = TRUE) must be bigger than any other value of x.) Use smaller and larger to implement equivalents of min(), max(), pmin(), pmax(), and new functions row_min() and row_max().
subNA=function(x,y,identity){
  if (is.na(x) && is.na(y)) {
    identity
  } else if (is.na(x)) {
    y
  } else {
    x
  }
}

smaller=function(x,y,na.rm=F){
  if(na.rm && (is.na(x)||is.na(y))) return(subNA(x,y,Inf))
  else if(is.na(x)||is.na(y)){
    return(NA)
  }
  if(x>y) return(y)
  else return(x)
}

larger=function(x,y,na.rm=F){
  if(na.rm && (is.na(x)||is.na(y))) return(subNA(x,y,-Inf))
  else if(is.na(x)||is.na(y)){
    return(NA)
  }
  if(x>y) return(x)
  else return(y)
}

min=function(...,na.rm=F){
  elements=c(...)
  Reduce(function(x,y){smaller(x,y,na.rm=na.rm)},elements)
}
max=function(...,na.rm=F){
  elements=c(...)
  Reduce(function(x,y){larger(x,y,na.rm=na.rm)},elements)
}

pmin=function(...,na.rm=F){
  inputlist=list(...)
  #Here I defined recycling of vector, maybe it is better not to recycle to prevent extra silent bugs
  if(all(sapply(inputlist,length)==1)){
    min(unlist(inputlist),na.rm=na.rm)
  }else{
    lens=vapply(seq_along(inputlist),function(x){length(inputlist[[x]])},numeric(1))
    inputlist=lapply(inputlist,rep,length=max(lens))
    simplify2array(
      apply(as.data.frame(inputlist),1,min,na.rm=na.rm)
    )
  }  
}


pmax=function(...,na.rm=F){
  inputlist=list(...)
  #Here I defined recycling of vector, maybe it is better not to recycle to prevent extra silent bugs
  if(all(sapply(inputlist,length)==1)){
    max(unlist(inputlist),na.rm=na.rm)
  }else{
    lens=vapply(seq_along(inputlist),function(x){length(inputlist[[x]])},numeric(1))
    inputlist=lapply(inputlist,rep,length=max(lens))
    simplify2array(
      apply(as.data.frame(inputlist),1,max,na.rm=na.rm)
    )
  }  
}

row_min=function(data){
  apply(data,1,min)
}

row_max=function(data){
  apply(data,1,max)
}

###Exercise2: Create a table that has and, or, add, multiply, smaller, and 
###larger in the columns and binary operator, reducing variant, vectorised 
###variant, and array variants in the rows.
###a. Fill in the cells with the names of base R functions that perform each of the roles.
###b. Compare the names and arguments of the existing R functions. How consistent are they? How could ###   you improve them?
# ###c. Complete the matrix by implementing any missing functions.
# a.              and   or  add   multiply   smaller   larger
# binary          &&    ||    +       *                   
# reducing var    all   any  sum     prod      min       max
# vectorised var  &     |     +       *        pmin      pmax
# array var                   +       *

#extra notes:
library(stringr)
library(ggplot2)
randomise <- function(f) f(runif(1e3))
randomise(mean)
#> [1] 0.5115665
randomise(mean)
#> [1] 0.503939
randomise(sum)

replicate(500,randomise(sum)) %>%
  data.frame(x = .) %>%
  ggplot(aes(x = x)) + geom_density()

###??Exercise3: How does paste() fit into this structure? What is the scalar binary function that underlies paste()? What are the sep and collapse arguments to paste() equivalent to? Are there any paste variants that donâ€™t have existing R implementations?
#paste(c(1,3),c(4,1),sep="-",collapse="+") : "1-4+3-1"
#binary is "+"? 
#sep is used in a Map function
#collapse is used in a Reduce function to apply "+" to every two results of Map function
#paste seems to be functional for all variants like vectorise, array, list, data.frame, etc

```
Function Operators
```{r function operators}
#########
###FOs###
#########
### A function operator is a function that takes one (or more) functions as input and returns a function as output. The result function act like a wrap of input functions
#Compared to closure, it need functions as input while closure don`t neccessarily need
#Compared to functionals, it returns a function rather than a data type
compact1 <- function(x) Filter(Negate(is.null), x)
compact2 <- partial(Filter, Negate(is.null))

##################
##Behavioural FO##
##################
#Behavioural FOs leave the inputs and outputs of a function unchanged, but add some extra behaviour. 
###Example function with three behaviours:
# Add a delay to avoid swamping a server with requests.
# Print to console every n invocations to check on a long running process.
# Cache previous computations to improve performance.
download_file <- function(url, ...) {
  download.file(url, basename(url), ...)
} #a wrapper of utils::download.file()
lapply(urls, download_file)

###To implement 3 behaviours:
i <- 1
for(url in urls) {
  i <- i + 1
  if (i %% 10 == 0) cat(".") #cat . for every 10 urls to show its still working
  Sys.delay(1)  #set delay for not harming server
  download_file(url)
}
#However, it is hard to understand the code without comment

###By create a FO we could encapsulate each behaviour . i.e:
lapply(urls, dot_every(10, delay_by(1, download_file)))

delay_by <- function(delay, f) {
  function(...) {
    Sys.sleep(delay)
    f(...)
  }
}
system.time(runif(100))
#>    user  system elapsed 
#>   0.001   0.000   0.000
system.time(delay_by(0.1, runif)(100))
#>    user  system elapsed 
#>   0.000   0.000   0.101

dot_every <- function(n, f) {
  i <- 1
  function(...) {
    if (i %% n == 0) cat(".")
    i <<- i + 1
    f(...)
  }
}

### arg f is better to be left as last argument. otherwise:
download <- dot_every(delay_by(download_file, 1), 10)
#would be very hard to follow
#better:
lapply(urls, dot_every(10, delay_by(1, download_file)))

####################
####Memoisation#####
####################
#A memoised function can run much faster because it stores all of the previous inputs and outputs, using more memory
#A realistic use of memoisation is computing the Fibonacci series. The Fibonacci series is defined recursively: the first two values are 1 and 1, then f(n) = f(n - 1) + f(n - 2)
#naive version of R implementation is slow cuz it computes f(n-2) f(n-1) duplicated times
fib <- function(n) {
  if (n < 2) return(1)
  fib(n - 2) + fib(n - 1)
}
system.time(fib(23))
#>    user  system elapsed 
#>   0.125   0.006   0.132
system.time(fib(24))
#>    user  system elapsed 
#>   0.194   0.003   0.196

###Now lets memoise the function!
fib2 <- memoise(function(n) {
  if (n < 2) return(1)
  fib2(n - 2) + fib2(n - 1)
})
system.time(fib2(23))
#>    user  system elapsed 
#>   0.004   0.000   0.004
system.time(fib2(24))
#>    user  system elapsed 
#>   0.001   0.000   0.000

###machanism of memoise is just store key and result into a cache list
runifm <- memoise(runif)
#this runifm is actually a function that do two conditional operation:
#1. if digest(list(...)) is in cache list, just get the result(prevent duplicated computation)
#2. if not in cache list, use the "runif" func stored in the closure to compute,then set the value with cache
runifm(5)
#> [1] 0.5374603 0.3466054 0.3079437 0.3631236 0.9511340
runifm(5)
#> [1] 0.5374603 0.3466054 0.3079437 0.3631236 0.9511340

###Finally
download <- dot_every(10, memoise(delay_by(1, download_file)))

##################################
##Capturing function invocations##
##################################
#it can be hard to see whatâ€™s going on inside of functionals
#we can use FOs to peer behind the curtain with tee()
ignore <- function(...) NULL
#use tee , a FO to show what`s going on inside functionals
tee <- function(f, on_input = ignore, on_output = ignore) {
  function(...) {
    on_input(...)
    output <- f(...)
    on_output(output)
    output
  }
}
#i.e:
g <- function(x) cos(x) - x
zero <- uniroot(g, c(-5, 5))
show_x <- function(x, ...) cat(sprintf("%+.08f", x), "\n")
zero <- uniroot(tee(g, on_input = show_x), c(-5, 5))
#what tee is doing is simply add a layer of show_x before g(x) 
#So the on_input,on_output could display input arg for g(x) and output of g(x)
zero <- uniroot(tee(g, on_output = show_x), c(-5, 5))

###In order to catch the output of func on_input , on_output,we actually have to 
#store them in a list.
#to maintain the list unchanged, we have to make the list a global var in a closure:
remember <- function() {
  memory <- list()
  f <- function(...) {
    # This is inefficient!
    memory <<- append(memory, list(...))
    invisible()
  }

  structure(f, class = "remember")
}
as.list.remember <- function(x, ...) {
  environment(x)$memory
}
#the print.remeber is inevitable
print.remember <- function(x, ...) {
  cat("Remembering...\n")
  str(as.list(x))
} #otherwise type a remember class will return a closure and append NULL arguments

###test remember func
locs <- remember()  #create a list of memory that append itself args foreach looop
vals <- remember()
zero <- uniroot(tee(g, locs, vals), c(-5, 5))
x <- unlist(as.list(locs))
error <- unlist(as.list(vals))
plot(x, type = "b"); abline(h = 0.739, col = "grey50")
plot(error, type = "b"); abline(h = 0, col = "grey50")

############
##Laziness##
############
#The FO we ve seen so far is commonly:
funop <- function(f, otherargs) {
  function(...) {
    # maybe do something
    res <- f(...)
    # maybe do something else
    res
  }
}
#One problem is that f()  is lazily evaluated, which means it may have changed before apply and evaluate
delay_by <- function(delay, f) {
  function(...) {
    Sys.sleep(delay)
    f(...)
  }
}
funs <- list(mean = mean, sum = sum)
funs_m <- lapply(funs, delay_by, delay = 0.1)
###since R 3.2 this lazy evaluation seems not to be a problem now

###Exercise1: Write a FO that logs a time stamp and message to a file every time a function is run.
timestamp=function(logfile,f){
   function(...){
     result=f(...)
     cat(date(),"\n",file=logfile,append=T)
     result
   }  
}

###Exercise2: What does the following function do? What would be a good name for it?
f <- function(g) {
  force(g)
  result <- NULL
  function(...) {
    if (is.null(result)) {
      result <<- g(...)
    }
    result
  }
}
runif2 <- f(runif)
runif2(5)
#> [1] 0.9740204 0.1269874 0.2954060 0.2944669 0.6048259
runif2(10)
#> [1] 0.9740204 0.1269874 0.2954060 0.2944669 0.6048259
#Answer: this function shall be called runOnce

###Exercise3 : defined a delay_by that instead ensures a certain time elapsed after function call
delay_by <- function(delay, f) {
  time=NULL
  function(...) {
    if( is.null(time)|| as.double(Sys.time()-time)>=delay){
      f(...)
      time<<-Sys.time()
    }else{
      Sys.sleep(delay-as.double(Sys.time()-time))
      f(...)
      time<<-Sys.time()
    }
  }
} #è€ƒè™‘ä¸‰ä¸ªé€»è¾‘ï¼šç¬¬ä¸€æ¬¡è¿è¡Œï¼Œå»¶è¯¯è¶…æ—¶åŽçš„è¿è¡Œå’Œä¸è¶…æ—¶çš„è¿è¡?

delay_by2 <- function(delay, f)
{
  delay_until <- Sys.time()

  function(...)
  {
    if(delay_until - Sys.time() > 0) {
      Sys.sleep(delay_until - Sys.time())
    }

    res <- f(...)
    delay_until <<- Sys.time() + delay
    res
  }  
} #BETTER!!!è€ƒè™‘ä¸¤ä¸ªé€»è¾‘ æ»¡è¶³delayå’Œä¸æ»¡è¶³delay:
  #æ»¡è¶³delay: è¦å»¶è¿Ÿçš„æ—¶é—´å°äºŽå½“å‰æ—¶é—´ï¼ˆç¬¬ä¸€æ¬¡è¿è¡Œå’Œè¶…æ—¶è¿è¡Œï¼?
  #ä¸æ»¡è¶³delay: è¦å»¶è¿Ÿåˆ°çš„æ—¶é—´å¤§äºŽå½“å‰æ—¶é—?,ç¨‹åºæ‹–å»¶åˆ°å»¶è¿Ÿæ—¶é—?

delay_by3 <- function(delay, f)
{
  executime <- 0
  #å¦‚æžœæ¢æˆ<-Sys.time(),æ‰§è¡Œæ—¶é—´å°±ä¸å¯¹äº†,å› ä¸ºç¬¬ä¸€æ¬¡æ‰§è¡Œå¹¶ä¸æ˜¯Sys.time
  #å¾—åˆ°ç»éªŒ:æ•°å€?,æ—¶é—´çš„åˆå§‹å€¼æœ€å¥½æ˜¯0
  function(...)
  {
    if(Sys.time()-executime < delay) {
      print(delay-(Sys.time()-executime))
      Sys.sleep(delay-(Sys.time()-executime))
    }#è·ç¦»ä¸Šæ¬¡callæ—¶é—´åœ¨delayå†?,åˆ™delay
    res <- f(...)
    executime <<- Sys.time()
    res
  }  
}#ä½†æ˜¯æ³¨æ„Sys.time()-executime < delay ->Sys.time()< delay+executime
 #åœ¨executime=0çš„æ—¶å€?,å¦‚æžœdelay å¼‚å¸¸å¤?,å¤§è¿‡çŽ°åœ¨æ—¶é—´çš„è¯,ä¼šå˜æˆTrue
 #ä½†å¦‚æžœå˜æ¢å¼å­ä¸ºSys.time()-delay<executime,åˆ™å¯è®¾åˆå§‹executimeä¸?-inf,åˆ™åˆå§‹å¿…false
 #Sys.time()-delay< -(Inf)
 #åœ¨delay2 funcä¸­delay_until - Sys.time() > 0 ,åœ¨ç¬¬ä¸€æ¬¡è¿è¡Œæ—¶æ°¸ä¸ä¸ºtrue(Sys.time-Sys.time==0!>0)
delay_by3gai <- function(delay, f)
{
  executime <- -Inf
  #å¦‚æžœæ¢æˆ<-Sys.time(),æ‰§è¡Œæ—¶é—´å°±ä¸å¯¹äº†,å› ä¸ºç¬¬ä¸€æ¬¡æ‰§è¡Œå¹¶ä¸æ˜¯Sys.time
  #å¾—åˆ°ç»éªŒ:æ•°å€?,æ—¶é—´çš„åˆå§‹å€¼æœ€å¥½æ˜¯0
  function(...)
  {
    if(Sys.time()- delay< executime) {
      print(delay-(Sys.time()-executime))
      Sys.sleep(delay-(Sys.time()-executime))
    }#è·ç¦»ä¸Šæ¬¡callæ—¶é—´åœ¨delayå†?,åˆ™delay
    res <- f(...)
    executime <<- Sys.time()
    res
  }  
}

f=function(){print("Executed once");print(Sys.time());return(NULL)}
g<-delay_by(1,f);g();Sys.sleep(2);g()
#####Note: if ä¸­çš„condition ä¸ç­‰å¼å·¦å³æ¢ä½å¯æœ‰å¤§ä¸åŒ.
#å¦‚ä½•æŽ¨å¯¼delay_until - Sys.time() > 0è¿™ä¸ªæ¡ä»¶?
########## è€ƒè™‘ä¸¤ä¸ªåŠ¨æ€å˜åŒ–çš„æ—¶é—´ç‚?(æ•°æ®)æ—?,æœ€å¥½ç”»ä¸¤æ¡çº?
#   establish    call      call2
# -----*-----------*--*----*---
#                  *----*
#       {         }{delay}
#{}{delay}çš„é•¿åº¦æœ€é•?,ç¬¬ä¸€æ¬¡callæ—¶establishçš„æ—¶é—´çŸ­äºŽæˆ–ç­‰äºŽcallçš„æ—¶é—?:time<-Sys.time;funciton(){if(time<=sys.time).... ä¹Ÿå³time <=sys.time
#ç¬¬äºŒæ¬¡callçš„æ—¶å€™call2çš„system.time>=call1time+delay,ä¹Ÿå³call1time+delay<=sys.time
#è¿™æ ·çš„è¯establish timeå°±åº”è¯¥æŒ‰ç…§calltime+delayæ¥å–å?,ç¬¬ä¸€æ¬¡establish timeä¸ºsys.time of FO ,callä¹‹åŽä¸ºsys.time of closure+delay

###Exercies5: There are three places we could have added a memoise call: why did we choose the one we did?
delay_by <- function(delay, f) {
  function(...) {
    Sys.sleep(delay)
    f(...)
  }
}

dot_every <- function(n, f) {
  i <- 1
  function(...) {
    if (i %% n == 0) cat(".")
    i <<- i + 1
    f(...)
  }
}
download.file=function(x){cat("downloading");print(x);}
download_file <- function(url, ...) {
  download.file(url, ...)
}
urls=as.list(c(LETTERS[1:4],rep("E",20))) #duplicate E
urls2=as.list(c(LETTERS)) #non duplicates
download <- memoise(dot_every(10, delay_by(1, download_file)))
#download() is just like
download <- dot_every(10, memoise(delay_by(1, download_file)))
#begin doting at 10,difference is 26 secs
download <- dot_every(10, delay_by(1, memoise(download_file)))
#test by non duplicates
start=Sys.time()
test=lapply(urls2,download)
print(Sys.time()-start)
#test by duplicates
start=Sys.time()
test=lapply(urls,download)
print(Sys.time()-start)
#as.list(environment(download))$cache$keys()
###Answer: if there`s no duplicates in urls2: the first run of all three is the same
###         But, second run of the first two  would be different:
###download <- memoise(dot_every(10, delay_by(1, download_file))) would not perform dot_every
###download <- dot_every(10, memoise(delay_by(1, download_file))) would dot, but would not delay
###download <- dot_every(10, delay_by(1, memoise(download_file))) would dot and also delay
###         if there`s duplicates in urls: first run would be different:
###download <- memoise(dot_every(10, delay_by(1, download_file))) not dotting if dup happend before ###                                                   dotting start number,get dup res rather fast
###download <- dot_every(10, memoise(delay_by(1, download_file))) would dot, get dup res fast
###download <- dot_every(10, delay_by(1, memoise(download_file))) would dot and delay anyway

###IMPORTANT SUMMARY:momoise store f in its closure, if calculated once, f would never function again
###We choose the middle one cuz we want the dot happen while the delay does not if dup in urls

###Exercise6: Why is the remember() function inefficient? How could you implement it in more efficient way?
remember <- function() {
  memory <- list()
  f <- function(...) {
    # This is inefficient!
    memory <<- append(memory, list(...))
    invisible()
  }

  structure(f, class = "remember")
}
as.list.remember <- function(x, ...) {
  environment(x)$memory
}
print.remember <- function(x, ...) {
  cat("Remembering...\n")
  str(as.list(x))
}

ignore <- function(...) NULL
tee <- function(f, on_input = ignore, on_output = ignore) {
  function(...) {
    on_input(...)
    output <- f(...)
    on_output(output)
    output
  }
}
g <- function(x) cos(x) - x

###test:
locs <- remember()
vals <- remember()
start=Sys.time()
zero <- uniroot(tee(g, locs, vals), c(-5, 5))
print(Sys.time()-start)
x <- unlist(as.list(locs))
error <- unlist(as.list(vals))

##Here we can hardly see its inefficiency but my guess is it lies in the recopy of list every time ##remember called


###Exercise7: Why does the following code, from stackoverflow, not do what you expect?
# return a linear function with slope a and intercept b.
f <- function(a, b) function(x) a * x + b
# create a list of functions with different parameters.
fs <- Map(f, a = c(0, 1), b = c(0, 1))
#fs[[1]](3) :4
###This is historically wrong because of lazy evaluation, 
###so in the past we had to f=function(a,b){force(a);force(b);}
###But, this is no longer a problem now.

################
###Output FOs###
################
## modify the output of a function.
#two simple modification: Negate() and failwith()
#two fundamental modification: capture_it() and time_it() ,change what FO does

###Minor modifications
#base::Negate() and plyr::failwith()
#Negate takes a function that returns a logical vector like is.null ...
#compact that use negate function to remove all null elements from a list
Negate=function(f){
  force(f)
  function(...){!f(...)}
}
compact=function(xlist){
  Filter(Negate(is.null),xlist)
}

#plyr::failwith() make function that throws an error return a default value when got error
#by silent=quiet , it simply ignores all errors and return out
failwith <- function(default = NULL, f, quiet = FALSE) {
  force(f)
  function(...) {
    out <- default
    try(out <- f(...), silent = quiet)
    out
  }
}
##failwith() is useful in conjunction with functionals: it can complete the iteration and then find out what went wrong.
# If any model fails, all models fail to fit:
models <- lapply(datasets, glm, formula = y ~ x1 + x2 * x3)
# If a model fails, it will get a NULL value
models <- lapply(datasets, failwith(NULL, glm),
  formula = y ~ x1 + x2 * x3)

# remove failed models (NULLs) with compact
ok_models <- compact(models)
# extract the datasets corresponding to failed models
failed_data <- datasets

###Changing what a function does
capture_it <- function(f) {
  force(f)
  function(...) {
    capture.output(f(...))
  }
}
str_out <- capture_it(str)
str(1:10)
#>  int [1:10] 1 2 3 4 5 6 7 8 9 10
str_out(1:10)
#> [1] " int [1:10] 1 2 3 4 5 6 7 8 9 10"

time_it <- function(f) {
  force(f)
  function(...) {
    system.time(f(...))
  }
}
compute_mean <- list(
  base = function(x) mean(x),
  sum = function(x) sum(x) / length(x)
)
x <- runif(1e6)

# Previously we used an anonymous function to time execution:
# lapply(compute_mean, function(f) system.time(f(x)))

# Now we can compose function operators:
call_fun <- function(f, ...) f(...)
lapply(compute_mean, time_it(call_fun), x)

###Exercise2:The evaluate package makes it easy to capture all the outputs (results, text, messages, warnings, errors, and plots) from an expression. Create a function like capture_it() that also captures the warnings and errors generated by a function.
library(evaluate)

capture_all <- function(f) {
  force(f)
  function(...) {
    evaluate(f(...), stop_on_error = 0, keep_warning = TRUE,
             keep_message = TRUE)
  }
}

a <- capture_all(log)
log(-1)
a(-1)

###Exercise3:Create a FO that tracks files created or deleted in the working directory (Hint: use dir() and setdiff().) What other global effects of functions might you want to track?

track2 <- function(f)
{
  force(f)
  function(...)
  {
    dir_before <- dir(getwd())

    res <- f(...)

    dir_after <- dir(getwd())

    cat("Added", setdiff(dir_after, dir_before), sep=" ")
    cat("Removed", setdiff(dir_before, dir_after), sep=" ")

    res
  }
}

#############
##Input FOs##
#############
###IN MINOR WAY: partial function variant
#It is a function that has certain arguments â€œfilled inâ€? already. This is called â€œpartial function applicationâ€?, and is implemented by pryr::partial().

f <- function(a) g(a, b = 1)
#replaced with:
f <- partial(g, b = 1)

#This is useful when we had to simplify code that working with lists of functions
funs2 <- list(
  sum = function(...) sum(..., na.rm = TRUE),
  mean = function(...) mean(..., na.rm = TRUE),
  median = function(...) median(..., na.rm = TRUE)
)
#we can write:
library(pryr)
funs2 <- list(
  sum = partial(sum, na.rm = TRUE),
  mean = partial(mean, na.rm = TRUE),
  median = partial(median, na.rm = TRUE)
)

###IN MAJOR WAY: change input types
#base::Vectorize() converts a scalar function to a vector function, 
#i.e
sample(1:5, 5:3) #unvectorized
sample2 <- Vectorize(sample, "size", SIMPLIFY = FALSE) #vectorize the size argument of sample
#SIMPLIFY = FALSE to ensure that our newly vectorised function always returns a list. This is usually what you want
sample2(1:5,5:3) 

#splat() converts a function that takes multiple arguments to a function that takes a single list of arguments.
#i.e
splat <- function (f) {
  force(f)
  function(args) {
    do.call(f, args)
  }
}

###Very usefull if you invoke a function with varying arguments:
x <- c(NA, runif(100), 1000)
args <- list(
  list(x),
  list(x, na.rm = TRUE),
  list(x, na.rm = TRUE, trim = 0.1) #trim both tail 10% of data
)
lapply(args, splat(mean))

###plyr::colwise() converts a vector function to one that works with data frames:
plyr::colwise(median)(mtcars)

###Exercise1: Our previous download() function only downloads a single file. How can you use partial() and lapply() to create a function that downloads multiple files at once? What are the pros and cons of using partial() vs. writing a function by hand?
#It is the same course of turning a single input func into a list input func
download=function(url){cat("Url is :",url,"\n")}
urls=list(ur1="sdfasfd",ur2="dfsfa")
download2=function(urls){lapply(urls,download)}
download2=function(...){lapply(...,FUN=download)} 
download2=partial(lapply,FUN=download) #NOTE!! Here we must have "FUN=download"!!Otherwise the order is not right!!
#Anwser, I think the pros of partial is it clearly shows what function it is partial from
#But, it makes it less flexible in manipulating args of a closure.

###Exercise2: Read the source code for plyr::colwise(). How does the code work? What are colwise()â€™s three main tasks? How could you make colwise() simpler by implementing each task as a function operator? (Hint: think about partial().)
function (.fun, .cols = true, ...) 
{
    if (!is.function(.cols)) {
        .cols <- as.quoted(.cols)
        filter <- function(df) eval.quoted(.cols, df)
    }
    else {
        filter <- function(df) Filter(.cols, df)
    }
    dots <- list(...)
    function(df, ...) {
        stopifnot(is.data.frame(df))
        df <- strip_splits(df)
        filtered <- filter(df)
        if (length(filtered) == 0) 
            return(data.frame())
        out <- do.call("lapply", c(list(filtered, .fun, ...), 
            dots))
        names(out) <- names(filtered)
        quickdf(out)
    }
}
###Answer:
###A filter function is created. The function first tests to see if .cols is a function or not. If it is a function, it creates a filter function to apply .cols to a data frame. If not a function, it creates a filter function to filter a data frame based on the indexes given in .cols.
# The output function is created. The first process in the output function is to apply the filter function to the input data frame.
# The output function applies any extra arguments to the data.frame using the ... supplied.
# A data frame is returned.
###To simplify, the filter function could be partial() ed

###Exercise4: Youâ€™ve seen five functions that modify a function to change its output from one form to another. What are they? Draw a table of the various combinations of types of outputs: what should go in the rows and what should go in the columns? What function operators might you want to write to fill in the missing cells? Come up with example use cases.
###Answer:
#               scalar	     vector	      matrix	     data frame	   arg1, arg2, ...	list(args)
# scalar						
# vector	     Vectorize()					
# matrix				                                       df_matrix()		
# data frame		            colwise()	  matrix_df()			
# arg1, arg2, ...						
# list(args)					                                                 splat()

#################
##Combining FOs##
#################
###function operators can take multiple functions as input. One simple example of this is plyr::each(). It takes a list of vectorised functions and combines them into a single function.
summaries <- plyr::each(mean, sd, median)
summaries(1:10)

###function composition
sapply(mtcars, function(x) length(unique(x)))
#A simple version of compose looks like this:
compose <- function(f, g) {
  function(...) f(g(...))
}
sapply(mtcars, compose(length, unique))

###Mathematically, function composition is often denoted with the infix operator, o, (f o g)(x).
"%o%" <- compose
sapply(mtcars, length %o% unique)

###%o% this makes funciton more succinct
square <- function(x) x^2
deviation <- function(x) x - mean(x)
#population mean
sd2 <- sqrt %o% mean %o% square %o% deviation #right most is the inner most
sd2(1:10)
###This type of programming is called tacit or point-free programming
### In this style of programming, you donâ€™t explicitly refer to variables. Instead, you focus on the high-level composition of functions rather than the low-level flow of data. The focus is on whatâ€™s being done, not on objects itâ€™s being done to. Since weâ€™re using only functions and not parameters, we use verbs and not nouns. This style is common in Haskell
###compose() is particularly useful in conjunction with partial(), because partial() allows you to supply additional arguments to the functions being composed. One nice side effect of this style of programming is that it keeps a functionâ€™s arguments near its name.

##rewrite download with compose style
download <- dot_every(10, memoise(delay_by(1, download_file)))

download <- pryr::compose(
  partial(dot_every, 10),
  memoise,
  partial(delay_by, 1),
  download_file
)

download <- partial(dot_every, 10) %o%
  memoise %o%
  partial(delay_by, 1) %o%
  download_file

###Exercise1:Implement your own version of compose() using Reduce and %o%. For bonus points, do it without calling function.
mycompose=function(f,g){
  Reduce(function(f,...){f(...)},list(f,g,2))
}
#Or if by %o% it means compose function rather than outer function:
compose <- function(f, g) {
  function(...) f(g(...))
}
my_compose=function(...){
  `%o%`=compose
  funlist=lapply(list(...),match.fun)
  Reduce(`%o%`,funlist)
}
square <- function(x) x^2
over_5 <- function(x) x/5
times_2 <- function(x) 2*x

my_fun <- my_compose(times_2, square, over_5)
my_fun(10)

###Exercise2: Extend and() and or() to deal with any number of input functions. Can you do it with Reduce()? Can you keep them lazy (e.g., for and(), the function returns once it sees the first FALSE)?
myOr=function(...){
  funlist=lapply(list(...),match.fun)
  function(...){
    resultlist=lapply(funlist, function(f){f(...)})
    Reduce(`||`,c(resultlist))
  }
}
chrOrnum=myOr(is.character,is.numeric)
chrOrnum(TRUE)
chrOrnum(1)

###Exercise3:Implement the xor() binary operator. Implement it using the existing xor() function. Implement it as a combination of and() and or(). What are the advantages and disadvantages of each approach? Also think about what youâ€™ll call the resulting function to avoid a clash with the existing xor() function, and how you might change the names of and(), not(), and or() to keep them consistent.
and <- function(f1, f2) {
  force(f1); force(f2)
  function(...) {
    f1(...) && f2(...)
  }
}

or <- function(f1, f2) {
  force(f1); force(f2)
  function(...) {
    f1(...) || f2(...)
  }
}

`%xor%`<-function(x,y){
  xor(x,y)
}
TRUE %xor% FALSE

###Exercise4:Above, we implemented boolean algebra for functions that return a logical function. Implement elementary algebra (plus(), minus(), multiply(), divide(), exponentiate(), log()) for functions that return numeric vectors.
maker=function(f){
  function(x,y){
    f(x,y)
  }
}
plus=maker(`+`)
plus(1,2)
```

Non-Standard Evaluation
```{r non-standard evaluation}
####################################
###Substitute paired with deparse###
####################################
# function arguments are represented by a special type of object called a "promise"
#substitute: promise->expression ; deparse: expression->character
g <- function(x) deparse(substitute(x))

# Basic use of this idea: avoid quotes
library(ggplot2)
# the same as
library("ggplot2")
g(1:10)

###Exercise1:One important feature of deparse() to be aware of when programming is that it can return multiple strings if the input is too long. For example, the following call produces a vector of length two:
g=function(...){deparse(substitute(...),nlines=1L)}
g(a + b + c + d + e + f + g + h + i + j + k + l + m +
  n + o + p + q + r + s + t + u + v + w + x + y + z)
###Why does this happen? Carefully read the documentation for ?deparse. Can you write a wrapper around deparse() so that it always returns a single string?

###Exercise4:f(), defined above, just calls substitute(). Why canâ€™t we use it to define g()? In other words, what will the following code return? First make a prediction. Then run the code and think about the results.
f <- function(x) substitute(x)
g <- function(x) deparse(f(x))
g(1:10) #x not evaluated because f(x) did not evaluate it
g(x)
g(x + y ^ 2 / z + exp(a * sin(b)))
###Answer: the substitute function takes promise as input ,f(1)=>1,
###Howerver,in the call f(x),the promise is x
###In other words, substitute will never evaluate the promise

################################
###special in subset func:NSE###
################################
#subset() is special because it implements different scoping rules: the expressions a >= 4 or b == c are evaluated in the specified data frame rather than in the current or global environments

###quote:  captures an unevaluated expression like substitute(), but doesnâ€™t do any of the advanced transformations that can make substitute() confusing
###quote() and eval() are opposites. In the example below, each eval() peels off one layer of quote()â€™s

####Difference between quote and substitute!!!:
#diff1: 
quote(quote(2 + 2))
#> quote(2 + 2)
eval(quote(quote(2 + 2)))
eval(eval(quote(quote(2 + 2))))

substitute(substitute(2+2))
eval(substitute(substitute(2+2)))
#> 2+2

#diff2:
test2=function(...){quote(...)}
test2(asdfa) # ...
test2=function(...){substitute(...)}
test2(asdf)  #asdf
#substitute takes promises as expression
#while quote takes arguments as what it is.

###eval second argument need not be limited to an environment: it can also be a list or a data frame.
#Useful ways of eval
eval(quote(x), data.frame(x = 40))
eval(quote(a >= 4), sample_df)

#Common mistakes with eval
eval(quote(a), sample_df)
#> [1] 1 2 3 4 5
eval(a, sample_df)
#> Error in eval(a, sample_df): object 'a' not found

#Use eval and quote to write subset2
subset2=function(df,con){
  judge=eval(substitute(con),df)
  return(df[judge & !is.na(judge),,drop=F])
}

###Exercise1: Predict the results of the following lines of code:
quote(eval(quote(eval(quote(eval(quote(2 + 2)))))))
#!!formost is quote! so everything after it is the result

###Exercise2: subset2() has a bug if you use it with a single column data frame. What should the following code return? How can you modify subset2() so it returns the correct type of object?
sample_df2 <- data.frame(x = 1:10)
subset2(sample_df2, x > 8)
#add drop=F: df[,,drop=F]

###Exercise3: The real subset function (subset.data.frame()) removes missing values in the condition. Modify subset2() to do the same: drop the offending rows.
###Answer:see changes above "judge & !is.na(judge)"

###Exercise5: The second argument in subset(,,select=...) allows you to select variables.How does it work?

subset3=function(dataf,con,select){
  judge<- if(missing(con)){
    rep(TRUE,dim(dataf)[1])
    }else{eval(substitute(con),dataf)}
  #Here we cannot use ifelse() for it only return vector length of 1
  if(!missing(select)){
    select=ifelse(is.numeric(substitute(select)),select,deparse(substitute(select)))
    return(dataf[judge & !is.na(judge),select,drop=F])
  }else{
    return(dataf[judge & !is.na(judge),,drop=F])  
  }
}
##But this doesn work if subset(test,,-x)
select <- function(df, vars) {
  vars <- substitute(vars)
  var_pos <- setNames(as.list(seq_along(df)), names(df)) 
  ##This is the only correct way to make use of -x, -cyl such expression work.
  pos <- eval(vars, var_pos)
###turn character or number to related col number
  df[, pos, drop = FALSE]
}
select(mtcars, -cyl)

###Exercise6 : What does evalq() do? Use it to reduce the amount of typing for the examples above that use both eval() and quote().
###Answer: 
N <- 3
env <- new.env()
assign("N", 27, envir = env)
## this version changes the visible copy of N only, since the argument
## passed to eval is '4'.
eval(N <- 4, env)
N
get("N", envir = env)
## this version does the assignment in env, and changes N only there.
evalq(N <- 5, env)
N
get("N", envir = env)
###So evalq change data within the envir
# 4
eval(quote(eval(quote(eval(quote(2 + 2))))))
evalq(evalq(evalq(2+2)))

# 4
eval(eval(quote(eval(quote(eval(quote(2 + 2)))))))
eval(evalq(evalq(evalq(2+2))))

# should be eval(quote(eval(quote(eval(quote(2 + 2))))))
# in this case, evalq cannot be used.
quote(eval(quote(eval(quote(eval(quote(2 + 2)))))))

####################
###Scoping issues###
####################
sample_df <- data.frame(a = 1:5, b = 5:1, c = c(5, 3, 1, 4, 1))
select <- function(df, vars) {
  vars <- substitute(vars)
  var_pos <- setNames(as.list(seq_along(df)), names(df))
  pos <- eval(vars, var_pos)
  df[, pos, drop = FALSE]
}
subset2 <- function(x, condition,select) {
  condition_call <- substitute(condition)
  r <- eval(condition_call, x)
  if(missing(select)){
    return(x[r, ,drop=F])  
  }else{
    select(x[r,,drop=F],select)
  }
  
}
subset2(sample_df, a == 4) #workded
x=4;y=4
subset2(sample_df, a == x) 
#not worked!! And here x is being replaced with dataframe in subset2 <- function(x, condition,select)
subset2(sample_df, a == condition)
#> Error in eval(expr, envir, enclos): object 'a' not found
subset2(sample_df, a == condition_call)
###These above all do not work because the x,condition,condition_call are names inside subset2
###It didn t look up in the parent.frame rather fetch the value inside subset enclose
###The way to make it right is to tell R to look for value in global
subset2(sample_df, a == y) #worked!!

###So There`s scoping issues
#The key is the third argument to eval(,,enclose): enclos. This allows us to specify a parent (or enclosing) environment for objects that don¡¯t have one (like lists and data frames)
#enclos is ignored if env is a real environment.
#So basically we should look for x in the env subset2 is called, which is parent.frame() inside subset.
subset2 <- function(x, condition,select) {
  condition_call <- substitute(condition)
  r <- eval(condition_call, x,parent.frame())
  if(missing(select)){
    return(x[r, ,drop=F])  
  }else{
    select(x[r,,drop=F],select)
  }
  
}
subset2(sample_df, a == x) #worked!!
subset2(sample_df, a == y) #worked!!

###Or use list2env(,parent=parent.frame()) to create a env that is child of parent.frame, rather the subset2`s enclosing env.
###Note: list2env(list,envir=...) will export list to env: ...

###Exercise1: plyr::arrange() works similarly to subset(), but instead of selecting rows, it reorders them. How does it work? What does substitute(order(...)) do? Create a function that does only that and experiment with it.
###Answer: substitute(order(...)) will convert promises first and turn order(promises) to expression

###Exercise2: What does transform() do? Read the documentation. How does it work? Read the source code for transform.data.frame(). What does substitute(list(...)) do?
###Answer: change old cols of dataframe or compute to create new cols
###        substitute(list(...)) :get expression of list(col1,col2)

###Exercise3: plyr::mutate() is similar to transform() but it applies the transformations sequentially so that transformation can refer to columns that were just created:
df <- data.frame(x = 1:5)
transform(df, x2 = x * x, x3 = x2 * x)  ##here in x3 = x2 *x , the x2 is not found
plyr::mutate(df, x2 = x * x, x3 = x2 * x)
###How does mutate work? What¡¯s the key difference between mutate() and transform()?
mutate=function (.data, ...) 
{
    stopifnot(is.data.frame(.data) || is.list(.data) || is.environment(.data))
    cols <- as.list(substitute(list(...))[-1]) # -1 to remove "list" that result from substitute
                                              # This is to get ... names as a list called: cols
    cols <- cols[names(cols) != ""]
    for (col in names(cols)) {
        .data[[col]] <- eval(cols[[col]], .data, parent.frame())
    }
    .data
}
###Note!!! very useful: as.list(substitute(list(...))), convert promises of xxx=xxx,.. to a list

###Compare eval in transform and mutate:
##transform: e <- eval(substitute(list(...)), `_data`, parent.frame())
test=function(...){eval(substitute(list(...)),sample_df,parent.frame())}
test(a=-a,b,c) #get a list of a,b,c cols in sample_df

##mutate: .data[[col]] <- eval(cols[[col]], .data, parent.frame()) ;col is each colname
test=function(.data,...){
  cols <- as.list(substitute(list(...))[-1]) #as.list to avoid evaluation
  print(cols)
  print(class(cols[[1]]))
  eval(cols[[ names(cols)[1] ]], .data, parent.frame())
}
test(sample_df,x2 = x * x, x3 = x2 * x)
#Here cols[[ names(cols)[1] ]] is the equation call (not character) stored in the named list of promises
#Then eval(call,.data,parent.frame())

####Exercise4: What does with() do? How does it work? Read the source code for with.default(). What does within() do? How does it work? Read the source code for within.data.frame(). Why is the code so much more complex than with()?
with.default=function (data, expr, ...) {
  eval(substitute(expr), data, enclos = parent.frame())
}
within.data.frame=function (data, expr, ...) 
{
    parent <- parent.frame()
    e <- evalq(environment(), data, parent) #convert data to a list like environment
    eval(substitute(expr), e)
    l <- as.list(e)
    l <- l[!vapply(l, is.null, NA, USE.NAMES = FALSE)]
    nD <- length(del <- setdiff(names(data), (nl <- names(l))))
    data[nl] <- l
    if (nD) 
        data[del] <- if (nD == 1) 
            NULL
        else vector("list", nD)
    data
}

with.default(sample_df,a-100) # not return whole sample_df,not copying sample_df,just calculate and return
within.data.frame(sample_df,a=a-100) # "=" is not allowed
e=new.env()
e$a="dfsadf"
eval(substitute(a=11),e) #only if '=' is replaced with <- ,it would work
eval(substitute(a<-11),e) #e$a is 11, only if e is envir will this make real change
#So
within.data.frame(sample_df,a<-a-100) #worked: dataframe is converted to a new copy of envir first
                                      #Then eval(expr,real_env) will change value in real_env

###################################
###Calling from another function###
###################################
#i.e.
subset2 <- function(x, condition) {
  condition_call <- substitute(condition)
  r <- eval(condition_call, x, parent.frame())
  x[r, ]
}

scramble <- function(x) x[sample(nrow(x)), ]

subscramble <- function(x, condition) {
  scramble(subset2(x, condition))
}

##But it doesnt work:
subscramble(sample_df, a >= 4)
# Error in eval(expr, envir, enclos) : object 'a' not found
# Because the substitute in subset2 will not recognize indirect promises 
# In summary, substitute only fetch the nearest promises at hand.

##What about set a as global variable?
a<-4
subscramble(sample_df, a == 4)
#>   a b c
#> 1 1 5 5
#> 2 2 4 3
#> 4 4 2 4
#> 5 5 1 1
#> 3 3 3 1

###The way to solve it is only to write an alternative version of the function that uses standard evaluation.
###ÕâÀï¿ÉÒÔ½«subset2¸ÄÎª½ÓÊÕsubstitute(condition)Îª²ÎÊý£¬¶ø²»ÊÇÔÚsubset2ÀïÔÙsubstitute
sample_df <- data.frame(a = 1:5, b = 5:1, c = c(5, 3, 1, 4, 1))
subset2_q<-function(df,con){
  r<-eval(con,df,parent.frame()) #to get what con really is ,envir should be parent call
  df[r,]
}
subset2 <- function(x, condition) {
  subset2_q(x, substitute(condition))
}

subscramble <- function(x, condition) {
  condition <- substitute(condition)
  scramble(subset2_q(x, condition))
}

##this subset2_q is kinda like escape hatch
##Base R functions tend to use a different sort of escape hatch. They often have an argument that turns off NSE. For example, require() has character.only = TRUE.
##But this may make function calls harder to understand

#############################################################################
##Important thing about scope of when using substitute to capture promises###
#############################################################################
##Another way of subscramble:
capCon<-function(...){
  substitute(...)
}
subset2_q<-function(df,con){
  r<-eval(con,df,parent.frame()) #to get what con really is ,envir should be parent call
  df[r,]
}
subscramble <- function(x, ...) {
  scramble(subset2_q(x, capCon(...)))
}
subscramble(sample_df, a >= 4)

#BUT! Use capCon<-function(con){  substitute(con)} will fail:
capCon<-function(condition){
  substitute(condition)
}
subset2_q<-function(df,con){
  r<-eval(con,df,parent.frame()) #to get what con really is ,envir should be parent call
  df[r,]
}
subscramble <- function(x, condition) {
  scramble(subset2_q(x, capCon(condition)))
}
subscramble(sample_df, a >= 4) #Failed
###ÕâÀïcapConÀïµÄsubstitueµÄscopeÊÇcapCon¶ø²»ÊÇµ÷ÓÃcapConµÄº¯Êý,¹Ê¶øsubset2_q eval parent.frameÊ±²¢²»ÔÚcapConÄÚ,¶øÓ¦¸ÃÊÇcapConµÄparent.frame()
###Òò´Ë,Ó¦¸ÃÓÃcapCon<-function(condiciton){substitute(condition, parent.frame())}:
capCon<-function(condition){
  substitute(condition,parent.frame())
}
subscramble(sample_df, a >= 4)
###ÕâÀïsubset2_qºÍcapCon¶¼ÓÃparent.frame,Òò´Ë,Á¬ÓÃÊ±scopeÒ»ÖÂÁË,Õâ²¿·Ö¿ÉÄÜ»»³Éenv²ÎÊý¿Éµ÷Îª×îºÏÊÊ
capCon<-function(condition,env=parent.frame()){
  substitute(condition,env)
}
subset2_q<-function(df,con,env=parent.frame()){
  r<-eval(con,df,env) #to get what con really is ,envir should be parent call
  df[r,]
}
subscramble <- function(x, condition,env=parent.frame()) {
  scramble(subset2_q(x,capCon(condition)))
}
outlayer=function(x,con){
  #env=parent.frame()
  subscramble(x,con)
}
outlayer(sample_df,a>=4) #con not found!
#we cannot capture condition and pass it to inner func properly in this way.so :
##Better turn off the capture of promises and use all safe hatches for inner functions!!
subset2_q<-function(df,con,env=parent.frame()){
  r<-eval(con,df,env) #to get what con really is ,envir should be parent call
  df[r,]
}
subscramble <- function(x, condition,env=parent.frame()) {
  print(condition)
  scramble(subset2_q(x,condition,env))
}
outlayer=function(x,con){
  subscramble(x,substitute(con),env=parent.frame())
}
outlayer(sample_df,a>=4)



###Exercise1: The following R functions all use NSE. For each, describe how it uses NSE, and read the documentation to determine its escape hatch.
# rm()  
# library() and require()
# substitute()
# data()
# data.frame()
###Answer: rm: Use dots <- match.call(expand.dots = FALSE)$... to  capture ... as a list
###            escape hatch: convert all names or character to character by names <- vapply(dots, as.character, "")
###require&library:  Use if (!character.only) package <- as.character(substitute(package)) to convert
###     substitute: escape hatch:quote?
###     data():  as.character(substitute(list(...))[-1L]) to capture only name of ...
###   data.frame(): same as above

###Exercise2: Base functions match.fun(), page(), and ls() all try to automatically determine whether you want standard or non-standard evaluation. Each uses a different approach. Figure out the essence of each approach then compare and contrast
###Answer: match.fun tests to see if the FUN argument is a function or character, then decides whether to use standard or non-standard evaluation.
###page does something similar. if (is.character(x) && length(x) == 1L){}else{deparse(substitute(x))}

###Exercise3: Add an escape hatch to plyr::mutate() by splitting it into two functions. One function should capture the unevaluated inputs. The other should take a data frame and list of expressions and perform the computation.
#Note mutate must use a=a+c not a<-a+c symbol
#This is cuz   cols <- as.list(substitute(list(a<-a-1))[-1]) »á±ä³ÉÃ»ÓÐÃû×ÖµÄÖµÎªa<-a-1µÄlist
#             ¶øas.list(substitute(list(a=-a-1))[-1]) »á±ä³ÉÃû×ÖÎªaµÄÖµÎªa-1µÄlist

# as.list(substitute(list()))»áÊ¶±ðÀïÃæµÄµÈºÅ£¬½«=Ç°ÃæµÄÃû×Ö´æÆðÀ´
mutate=function (.data, ...) 
{
    stopifnot(is.data.frame(.data) || is.list(.data) || is.environment(.data))
    cols <- as.list(substitute(list(...))[-1])
    cols <- cols[names(cols) != ""]
    for (col in names(cols)) {
        .data[[col]] <- eval(cols[[col]], .data, parent.frame())
    }
    .data
}
###Answer: Escape hatch: 
capDots<-function(...){
  cols <- as.list(substitute(list(...))[-1])
  cols <- cols[names(cols) != ""]
  cols
}
mutate_p=function(.data,cols){
  for (col in names(cols)) {
        .data[[col]] <- eval(cols[[col]], .data, parent.frame())
    }
  .data
}
mutate=function(.data,...){
  stopifnot(is.data.frame(.data) || is.list(.data) || is.environment(.data))
#   cols <- as.list(substitute(list(...))[-1])
#   cols <- cols[names(cols) != ""]
  cols=capDots(...)
  mutate_p(.data,cols)
}
sample_df <- data.frame(a = 1:5, b = 5:1, c = c(5, 3, 1, 4, 1))
mutate(sample_df,a=a-1)
###The reason why this work is that the final function mutate use ... as a way to pass condition
###dots can enable sub functions to capture the con, otherwise:
capCon=function(con){substitute(con)}
test=function(cond){capCon(cond)}
test(a>=3)
#this resulted in "cond" rather than a>=3, while:
test=function(...){capCon(...)}
test(a>=3)
# a>=3

###??Exercise4: What¡¯s the escape hatch for ggplot2::aes()? What about plyr::()? What do they have in common? What are the advantages and disadvantages of their differences?


###Exercise5: The version of subset2_q() I presented is a simplification of real code. Why is the following version better?
subset2_q <- function(x, cond, env = parent.frame()) {
  r <- eval(cond, x, env)
  x[r, ]
}
c=3
subset2_q(sample_df,substitute(a>=c)) 
e=new.env()
e$c=4
eval(expression(c),e) ##check c value in e
subset2_q(sample_df,expression(a>=c),env=e) 
#####IMPORTANT!!!!
###ÕâÀïµÄa,c ±»µ±³ÉÊÇsample_dfµÄcolumnÁË!!!!
e$d=4
subset2_q(sample_df,expression(a>=d),env=e) 
####Answer, this is why add env parameter to subset2_q is useful!

##############
##substitute##
##############
#When run substitute from the global environment, it never does substitutions: in fact, in this situation it behaves just like quote()

##So better use subs() func provided by pryr:
subs=function (x, env = parent.frame()){
    if (identical(env, globalenv())) {
        env <- as.list(env)
    }
    substitute_q(substitute(x), env)
}
to_env=pryr:::to_env
substitute_q=function (x, env) 
{
    stopifnot(is.language(x))
    env <- to_env(env)
    call <- substitute(substitute(x, env), list(x = x))
   
    eval(call)
}
a=2
substitute(a) #a
subs(a) #2
###The trick is to pass a new env list to substitute and also name: "a" to substitute and
###Finally get: substitute(a,env) where env is a list same as global
#First, we do: substitute(x) then pass it to a escape hatch 
test=function(x){
  env=as.list(globalenv()) #create a list of globalenv
  env=env<-pryr:::to_env(env); #convert list back to env
  escapeHatch(substitute(x), env) #pass substitue(a) and env to escape hatch
} 
escapeHatch=function(x,env){
  # substitute(x,env) :get x cuz no x is found in env
  # substitute(x) : THIS WOULD ONLY GET substitute(x) cuz 
  call=substitute(substitute(x, env), list(x = x))
  # This means substitute the inside "substitute(x,env)" with list(x=x)
  # This links x to promise x which is name: "a" and this would result in a call like:
  # Substitute(a,env)
  eval(call)
  #Finally we just eval the substitute call
}

####substitute rules without setting env to substitute####
###x, y is ordinary value so it¡¯s replaced by the value of the variable( Rule 1).
x <- quote(mpg)
y <- quote(disp)
subs(xyplot(x ~ y, data = mtcars))
#> xyplot(mpg ~ disp, data = mtcars)

###It¡¯s even simpler inside a function, because we don¡¯t need to explicitly quote the x and y variables (rule 2):a promise (a function argument), it¡¯s replaced by the expression associated with the promise.
xyplot2 <- function(x, y, data = data) {
  substitute(xyplot(x ~ y, data = data))
}
xyplot2(mpg, disp, data = mtcars)
#> xyplot(mpg ~ disp, data = mtcars)

###Rule 3: dots will be replaced by the contents of ...
xyplot3 <- function(x, y, ...) {
  substitute(xyplot(x ~ y, ...))
}
xyplot3(mpg, disp, data = mtcars, col = "red", aspect = "xy")
#> xyplot(mpg ~ disp, data = mtcars, col = "red", aspect = "xy")

########################################
##Adding an escape hatch to substitute##
########################################




#######################################
###Summary in Nonstandard Evaluation###
#######################################
capCon=function(con){substitute(con)}
outlayer=function(...){capCon(...)}
outlayer=function(cond){capCon(cond)}
#1. use a capture function to cap condition as expression is generally a bad idea: 
#   This would only work when outlayer func using capCon is passing "..." to capCon,
#   rather than passing cond to capCon
#
subset2_q <- function(x, cond, env = parent.frame()) {
  r <- eval(cond, x, env)
  x[r, ]
}
#2. when a funciton invoke eval to compute, better provide a env parameter for eval enclos=
#
test=function(){a=1;substitute(a);};test() #under environment(): 1
test=function(){a=1;substitute(a,env=parent.frame());};test() #under global env: a
#3.  When run from the global environment, it never does substitutions: in fact, in this situation it behaves just like quote()

#4: Ïña=a-3ÕâÑùµÄ²ÎÊýÊÇ²»¿ÉÒÔÖ±½ÓsubstituteµÄ,±ØÐëÍ¨¹ý×ª»»Îªas.list(substitute(list(...)))µÄ·½Ê½µÃµ½,
#   ¶øÆäËûÈçc=4;a>=c, ¿ÉÒÔÍ¨¹ýÒÔÏÂcapConÀ´²¶»ña>=4µÄcall: 
capCon=function(con,env=globalenv()){
  print("in capcon")
  if(is.call(con)){
    print("Is call")
    #print(con)
    call=substitute(substitute(con,env),list(con=con));
    eval(call)  
  }else{
    stop("con shall be a call!!")
  }
}
outlayer=function(cond,env=parent.frame()){
  print("in outlayer")
  print(cond)
  capCon(cond,env)
}
outoutlayer=function(cond,env=parent.frame()){
  #con=capCon(substitute(cond),env)
  #print(con)
  outlayer(substitute(cond),env)
}
e=new.env()
e$c=3
outoutlayer(a>=c,e)

#5 ¶øÍ¨¹ýÖ±½Ósubstitute(x,e) ÎÞ·¨Ö±½Ó»ñµÃe ÖÐµÄ±äÁ¿ÐÅÏ¢ÒòÎªËû»áÏÈ¿´xÕâ¸öÊÇ·ñÔÚeÖÐ:
test=function(x,e){substitute(x,e)}; #-1 If it (x) is not a bound symbol in env, it is unchanged
test(a>=c,e) #x 
e$x=4 #add x symbol to e
test(a>=c,e) #4, Now since it found x in e, i return 4!!!

test=function(x){substitute(x)} #-2Now x is the promise object, formal argument to a function or explicitly created using delayedAssign()
test(a>=c) $a>=c #In this turn, the expression slot of the promise replaces the symbol.

test=function(x){substitute(x)} #-3 Now the env is environment(), an ordinary variable will be
test(a>=c)                      #substituted

test2=function(x,e){capCon(substitute(x),e)};test2(a>=c,e)
##so the machanism is just as:
test3=function(x,e){x=substitute(x);eval(substitute(substitute(x,e),list(x=x)))} 
#this is just like typing, which is what test3 and capCon get at last:
substitute(a>=c,e)

###In above funcs, test2 is quite like pryr::subs that increased fault tolerances




```



